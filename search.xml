<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS中的原始值、引用值、按值传递</title>
    <url>/2021/09/20/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E5%80%BC%E3%80%81%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p>对于JS中的变量只存储两种类型的值，原始值和引用值。</p>
<h4 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h4><p>原始值就是最简单的数据，也就是几种基本数据类型的值。原始值存储在变量上，我们在访问原始值是按值访问的，操作的就是存储在变量中的实际值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1=<span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> num2=num1</span><br><span class="line"><span class="built_in">console</span>.log(++num1)		<span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log(num2)		<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>第一行num1变量存储数值5，第二行num2初始化为num1，该变量也同样存储数值5。但是这两个变量中的数值5是完全独立的，两个变量可以独立使用，互不干扰。如下图：</p>
<p><img src="/2021/09/20/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E5%80%BC%E3%80%81%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/liucheng1-1.png"></p>
<center>图1-1 num1初始化</center>

<p><img src="/2021/09/20/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E5%80%BC%E3%80%81%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/liucheng1-2.png"></p>
<center>图1-2 num2初始化</center>

<h4 id="引用值"><a href="#引用值" class="headerlink" title="引用值"></a>引用值</h4><p>引用值是保存在内存中的对象，在JS中不允许我们直接去访问内存位置，所以就不能直接操作对象所在的内存空间。保存在变量中的值为引用值，我们实际操作的是该对象的引用而非对象本身。换句话说就是我们通过操作保存在变量中的引用值来间接操作对内存中的对象，也就是按引用访问。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1=<span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="keyword">let</span> obj2=obj1</span><br><span class="line">obj1.num=<span class="number">1</span>		<span class="comment">//为obj1对象添加num属性属性值为1</span></span><br><span class="line">consol.log(obj2.num)	<span class="comment">//1		通过obj2也可以访问num属性，这是为什么呢？</span></span><br></pre></td></tr></table></figure>

<p>在第一行中我们为obj1“new”出了一个新的实例对象，在第二行中执行了一个复制值的操作，虽然有值的复制但是并没有在内存中重新开辟新的空间，也就是说这一步复制的值就相当于一个指针，该指针指向内存中的对象(obj1所指向的对象)。这样obj2和obj1通过指针指向同一内存地址，无论哪一个改变了，内存中的对象都会改变。如下图：</p>
<p><img src="/2021/09/20/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E5%80%BC%E3%80%81%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/liucheng2-1.png"></p>
<center>图2-1 执行复制值之前</center>

<p><img src="/2021/09/20/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E5%80%BC%E3%80%81%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/liucheng2-2.png"></p>
<center>图2-2执行复制值之后</center>

<h4 id="函数传参-按值传递"><a href="#函数传参-按值传递" class="headerlink" title="函数传参(按值传递)"></a>函数传参(按值传递)</h4><p>JS中所有函数传参都是按值传递的。也就是说传递的参数会被复制到函数内部的参数中，就像两个变量进行复制操作一样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ++num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> n=<span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(add(n))		<span class="comment">//11</span></span><br><span class="line"><span class="built_in">console</span>.log(n)		<span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p>我们可以发现对于原始值(基本数据类型)传参(按值传递)，函数内部的操作不会影响到外部，这很好理解。正如开头说的，传参相当于执行了复制操作，对于原始值复制值两个变量是完全独立的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPerson</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">	obj.name=<span class="string">&quot;kobe&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p=<span class="keyword">new</span> <span class="built_in">Object</span>()		<span class="comment">//创建一个p对象</span></span><br><span class="line">setPerson(p)</span><br><span class="line"><span class="built_in">console</span>.log(p.name)		<span class="comment">//kobe</span></span><br></pre></td></tr></table></figure>

<p>对于引用值传参(按值传递)，函数内部的操作会影响到外部，很多人认为这就是按引用传递其实是不对的。看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPerson</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">	obj.age=<span class="number">20</span></span><br><span class="line">    obj=<span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    obj.age=<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p =<span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">setPerson(p)		</span><br><span class="line"><span class="built_in">console</span>.log(p.age)		<span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p>如果对于引用值函数传参是按引用传递的话，在函数体内部obj指向了一个新的对象，并且为对象添加age属性，属性值为22 ，外部p也应指向新对象并且age也应该为22，但是结果确是20,足以说明这并不是按引用传递而是按值传递。</p>
<p>在函数体内的过程：</p>
<p>按值传递实参p会将指针复制给实参obj，此时他们共同指向存放在全局作用域堆内存中的对象，所以添加属性age并为其赋值外部实参也会产生相应的变化</p>
<p><img src="/2021/09/20/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E5%80%BC%E3%80%81%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/liucheng3-1.png"></p>
<center>图3-1 传递参数</center>

<p>obj在函数内部被重写，他的指针指向了本地对象，而原本的实参p是不受影响的，这个本地对象在函数执行之后会被销毁。</p>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2组件间通信---全局事件总线</title>
    <url>/2021/09/04/Vue2%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1-%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><p>实现任意组件间通信</p>
<hr>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>相对于接受者和传递者来说全局事件总线相当于一个第三人，接受者会给全局事件总线绑定自定义事件，回调在自己的methods中。传递者去触发这个第三人绑定的自定义事件，回掉参数就是要传递的数据、</p>
<hr>
<h3 id="安装全局事件总线："><a href="#安装全局事件总线：" class="headerlink" title="安装全局事件总线："></a>安装全局事件总线：</h3><h5 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.__proto__.$bus = <span class="built_in">this</span>;</span><br><span class="line">        <span class="comment">// Vue.prototype.$bus = this</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这里的$bus就是我们所说的“第三人”，我们给Vue实例的原型对象添加$bus属性，属性值为一个Vue实例(我们当前new出来的实例对象)，这样做的目的就是为了让所有的组件实例对象都可以在自己的原型对象上找到找到这个$bus。</p>
<p>这里存在一个关系：VueComponent.prototype.__ proto __ === Vue.prototype</p>
<p>说白了就是给Vue的原型对象上添加$bus其他的组件实例都可以通过原型链去找到这个属性</p>
<h5 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h5><p>当然，我们还可以另外定义一个js文件创建一个Vue实例对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">expotr <span class="keyword">default</span> <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure>

<p>这一种方式我们要在使用他的组建中引入，对于以上两种方式都可以采用，它们都是找一个”第三人“</p>
<hr>
<h3 id="使用全局事件总线："><a href="#使用全局事件总线：" class="headerlink" title="使用全局事件总线："></a>使用全局事件总线：</h3><p>全部以第一种安装方式为例：</p>
<h5 id="接收数据："><a href="#接收数据：" class="headerlink" title="接收数据："></a>接收数据：</h5><p>brother1组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Brother1&#x27;</span>,</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$bus.$on(<span class="string">&#x27;showMsg&#x27;</span>,<span class="built_in">this</span>.show)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="传递数据："><a href="#传递数据：" class="headerlink" title="传递数据："></a>传递数据：</h5><p>brother2组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Brother2&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$bus.$emit(<span class="string">&#x27;showMsg&#x27;</span>,<span class="string">&#x27;我是Brother2&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>brother3组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Brother3&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$bus.$emit(<span class="string">&#x27;showMsg&#x27;</span>,<span class="string">&#x27;我是Brother3&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>App组件的模板：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Brother1</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Brother2</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Brother3</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">我是Brother2</span><br><span class="line">我是Brother3</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>相比于props和子传父自定义事件全局事件总线可以做到任意键组件间通信，区别于子传父自定义事件的父组件给子组件绑定自定义事件，全局事件总线的方式是找了一个“第三人”，大家都可以为这个第三人去绑定自定义事件，也可以去触发这个自定义事件来达到任意组件间通信的目的。</p>
]]></content>
      <categories>
        <category>关于Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2组件间通信---子传父值自定义事件</title>
    <url>/2021/09/03/Vue2%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1---%E5%AD%90%E4%BC%A0%E7%88%B6%E5%80%BC%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><p>父组件可以接受到子组件传递的数据，适用于组件间通信。</p>
<hr>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>子组件要给父组件传递数据，此时要在父组件中给子组件绑定一个自定义事件，回调写在父组件中。那么触发这个自定义事件的就是子组件，传递的参数就是子组件要给父组件传递的数据。</p>
<hr>
<h3 id="绑定自定义事件的两种方式："><a href="#绑定自定义事件的两种方式：" class="headerlink" title="绑定自定义事件的两种方式："></a>绑定自定义事件的两种方式：</h3><ul>
<li><h5 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a>第一种方式：</h5></li>
</ul>
<p>父组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Son</span> @<span class="attr">show</span>=<span class="string">&quot;showName&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Son <span class="keyword">from</span> <span class="string">&#x27;./Son.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Father&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">showName</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">components</span>:&#123;</span><br><span class="line">    Son</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Son&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$emit(<span class="string">&#x27;show&#x27;</span>,<span class="string">&quot;Son子组件&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">控制台结果：</span><br><span class="line"></span><br><span class="line">Son子组件</span><br></pre></td></tr></table></figure>



<ul>
<li><h5 id="第二种方式："><a href="#第二种方式：" class="headerlink" title="第二种方式："></a>第二种方式：</h5></li>
</ul>
<p>父组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Son</span> <span class="attr">ref</span>=<span class="string">&quot;MySon&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> Son <span class="keyword">from</span> <span class="string">&#x27;./Son.vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>:<span class="string">&#x27;Father&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">ShowName</span>(<span class="params">name</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">console</span>.log(name)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">this</span>.$refs.MySon.$on(<span class="string">&#x27;show&#x27;</span>,<span class="built_in">this</span>.ShowName)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    Son</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toFather&quot;</span>&gt;</span>为Father传值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>:<span class="string">&#x27;Son&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">toFather</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;show&#x27;</span>,<span class="string">&quot;Son子组件&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">控制台结果：</span><br><span class="line"></span><br><span class="line">Son子组件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="区别-小坑-："><a href="#区别-小坑-：" class="headerlink" title="区别(小坑)："></a>区别(小坑)：</h3><p>两种方式的目的都是为了子传父值，不过在这里需要注意的是第二种方式在为子组件绑定自定义事件的时机与第一种方式不同，第二种是在整个页面挂载之后对子组件绑定自定义事件，而Vue的执行机制是子组件比父组件先进行渲染，也就是说子组件都已经渲染完毕了之后我们才给它绑定自定义事件，所以子组件中触发自定义事件的函数不可以在mounted钩子中执行。通俗点说就是子组件比父组件先进行渲染，子组件的mounted函数比父组件的先执行，在执行的时候父组件的自定义事件还没有绑定(查无此人)。所以在示例中对于第二种方式我们在子组件中用按钮去触发自定义事件。</p>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><ol>
<li> 我们最好在组件销毁之前对自定义事件进行解绑，this.$off (‘自定义事件’), 这一过程可以在beforeDestroy钩子中执行</li>
<li> 对于绑定原生DOM事件也可以用native修饰符修饰  如： @click.native=”…” 这样click事件就变成了原生Dom事件不会被当做自定义事件执行。</li>
<li> 注意点：对于第二种方式绑定自定义事件的回调函数要么写成命名函数的方式到methods中，要么写成箭头函数的形式，否则this指向不是组件实例。</li>
</ol>
]]></content>
      <categories>
        <category>关于Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2组件间通信——父传子值props</title>
    <url>/2021/09/02/Vue2%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1---%E7%88%B6%E4%BC%A0%E5%AD%90%E5%80%BCprops/</url>
    <content><![CDATA[<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><p>子组件可以接收到父组件传递的数据信息，适用于组件间通信，对于父传子props配置相相对来说是较为方便的</p>
<hr>
<h3 id="传递方式："><a href="#传递方式：" class="headerlink" title="传递方式："></a>传递方式：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Son</span> <span class="attr">:msg</span>=<span class="string">&quot;Str&quot;</span> <span class="attr">:Job</span>=<span class="string">&#x27;job&#x27;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> Son <span class="keyword">from</span> <span class="string">&#x27;./Son.vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>:<span class="string">&#x27;Father&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">Str</span>:<span class="string">&#x27;hello&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">job</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">salary</span>:<span class="string">&#x27;30k&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    Son</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">传递方式很简单，只需在子组件中传入父组件想传递的信息即可，msg和Job是我们的自定义写法，不过要注意的是在前面要加v-bind指令，</span><br><span class="line">不然“ ”中的值会被当做字符串传入Son组件中</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="接受方式："><a href="#接受方式：" class="headerlink" title="接受方式："></a>接受方式：</h3><ul>
<li><h5 id="数组类型的接收方式"><a href="#数组类型的接收方式" class="headerlink" title="数组类型的接收方式"></a>数组类型的接收方式</h5></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Son&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>:[<span class="string">&#x27;msg&#x27;</span>,<span class="string">&#x27;Job&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.Job)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">__ob__</span>: Observer&#125;</span><br><span class="line"><span class="attr">salary</span>: <span class="string">&quot;30k&quot;</span></span><br><span class="line"><span class="attr">__ob__</span>: Observer &#123;<span class="attr">value</span>: &#123;…&#125;, <span class="attr">dep</span>: Dep, <span class="attr">vmCount</span>: <span class="number">0</span>&#125;</span><br><span class="line">get salary: ƒ reactiveGetter()</span><br><span class="line">set salary: ƒ reactiveSetter(newVal)</span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line">用数组的形式来接收传递过来的信息看起来起来像是傻瓜形式的接受，因为我们并没有对接受结果做限制。我们可以看到在钩子里可以使用</span><br><span class="line"><span class="built_in">this</span>来拿到数据，所以说传递过来的信息也是在组件实例身上的。</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="带有限制的接收方式"><a href="#带有限制的接收方式" class="headerlink" title="带有限制的接收方式"></a>带有限制的接收方式</h5></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Son&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">props</span>:&#123;</span><br><span class="line">    <span class="attr">msg</span>:&#123;</span><br><span class="line">      <span class="attr">type</span>:<span class="built_in">String</span>,      <span class="comment">//类型</span></span><br><span class="line">      <span class="attr">required</span>:<span class="literal">false</span>,   <span class="comment">//是否必填</span></span><br><span class="line">      <span class="attr">default</span>:<span class="string">&#x27;你好&#x27;</span>     <span class="comment">//默认值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">Job</span>:<span class="built_in">Object</span>			<span class="comment">//简写</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.Job)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">你好</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">__ob__</span>: Observer&#125;</span><br><span class="line"><span class="attr">salary</span>: <span class="string">&quot;30k&quot;</span></span><br><span class="line"><span class="attr">__ob__</span>: Observer &#123;<span class="attr">value</span>: &#123;…&#125;, <span class="attr">dep</span>: Dep, <span class="attr">vmCount</span>: <span class="number">0</span>&#125;</span><br><span class="line">get salary: ƒ reactiveGetter()</span><br><span class="line">set salary: ƒ reactiveSetter(newVal)</span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line">相比于数组类型接收数据，采用配置对象的形式来接收数据可以很好地限制父组件传递过来的数据信息。上面在父组件中并没有传递msg，所以</span><br><span class="line">msg打印出的结果是配置项中的默认值 你好</span><br></pre></td></tr></table></figure>



<p>这里我们可能有个疑问，父向子传递数据之后 子组件会永久存储着传递过来的数据吗？对于不同的父组件呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Father</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Son</span> <span class="attr">:msg</span>=<span class="string">&quot;Str2&quot;</span> <span class="attr">:Job</span>=<span class="string">&quot;myjob&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> Father <span class="keyword">from</span> <span class="string">&#x27;./components/Father.vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> Son <span class="keyword">from</span> <span class="string">&#x27;./components/Son.vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>:<span class="string">&#x27;App&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">Str2</span>:<span class="string">&#x27;world&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">myjob</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">salary</span>:<span class="string">&#x27;10k&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  Father,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  Son</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">你好</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">__ob__</span>: Observer&#125;</span><br><span class="line"><span class="attr">salary</span>: <span class="string">&quot;30k&quot;</span></span><br><span class="line"><span class="attr">__ob__</span>: Observer &#123;<span class="attr">value</span>: &#123;…&#125;, <span class="attr">dep</span>: Dep, <span class="attr">vmCount</span>: <span class="number">0</span>&#125;</span><br><span class="line">get salary: ƒ reactiveGetter()</span><br><span class="line">set salary: ƒ reactiveSetter(newVal)</span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line">world</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">__ob__</span>: Observer&#125;</span><br><span class="line"><span class="attr">salary</span>: <span class="string">&quot;10k&quot;</span></span><br><span class="line"><span class="attr">__ob__</span>: Observer &#123;<span class="attr">value</span>: &#123;…&#125;, <span class="attr">dep</span>: Dep, <span class="attr">vmCount</span>: <span class="number">0</span>&#125;</span><br><span class="line">get salary: ƒ reactiveGetter()</span><br><span class="line">set salary: ƒ reactiveSetter(newVal)</span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​     这里我们在App组件中也向Son组建中传递了相关数据，我们可以看出控制台分别打印了两次 msg和Job 的结果。 很明显Son组件作为子组件对于Faher组件和App组件分别挂载了一次，对应的mounted钩子也分别执行一次，每次打印的信息都是对应父组件传递的相关数据。</p>
]]></content>
      <categories>
        <category>关于Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3中的的ref函数和reactive函数及其浅层次响应式原理</title>
    <url>/2021/08/31/Vue3%E4%B8%AD%E7%9A%84%E7%9A%84ref%E5%87%BD%E6%95%B0%E5%92%8Creactive%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E6%B5%85%E5%B1%82%E6%AC%A1%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>​        </p>
<h3 id="ref函数："><a href="#ref函数：" class="headerlink" title="ref函数："></a>ref函数：</h3><p><strong>语法：const xxx = ref (initValue)<br>接受的数据类型：基本类型，对象类型<br>作用：把参数加工成一个响应式对象，全称为reference对象(我们下面一律简称为ref对象)<br>核心原理：响应式依赖Object.defineProperty( )的get( )和set( )</strong></p>
<hr>
<h5 id="Ref函数对于基本数据类型的参数"><a href="#Ref函数对于基本数据类型的参数" class="headerlink" title="Ref函数对于基本数据类型的参数"></a>Ref函数对于基本数据类型的参数</h5><ul>
<li><h6 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h6></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;Str&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Str =ref(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      Str</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  这里我们定义了一个Str变量来接收ref加工生成的ref对象，我们都知道对象的数据都是以键值对的形式存储的，但是在这里为什么直接把Str给<span class="keyword">return</span>出去，</span><br><span class="line">并且模板里可以直接写Str这个对象呢,我们的源数据呢？带着这个疑问我们来输出一下Str</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Str =ref(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(Str)</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      Str</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">打印结果如下：</span><br><span class="line">RefImpl</span><br><span class="line"><span class="attr">__v_isRef</span>: <span class="literal">true</span></span><br><span class="line"><span class="attr">_rawValue</span>: <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="attr">_shallow</span>: <span class="literal">false</span></span><br><span class="line"><span class="attr">_value</span>: <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="attr">value</span>: <span class="string">&quot;hello&quot;</span></span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line">  在这里我们看到了ref对象身上的一个属性 value,没错，我们存入的值就对应在value属性上，至于为什么直接<span class="keyword">return</span>出是Str而不是Str.value 。是因为Vue帮了我们</span><br><span class="line">一个忙，我们在这里可以简写，<span class="keyword">return</span>出去的Str 就相当于Str.value ，当然 非要写.value的形式也不是不可以。不过这里需要注意的是，在</span><br><span class="line">setup函数中操作Str中的数据不可以简写。</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h6></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   对于基本数据类型说完了它的基本用法，下面我们来说说他的响应式原理，也就是我们为什么非要用一个ref对象来接受数据，而不是直接就定义好一个字符</span><br><span class="line">串‘hello’然后去直接操作这个字符串？</span><br><span class="line"></span><br><span class="line">  对于ref函数，数据参数和它加工生成的ref对象二者存在着某种“契约”，我们把加工好的参数也就是ref对象交出去之后，我们直接操作修改的就是ref</span><br><span class="line">对象上的value属性，因为这个契约的存在，以至于在修改属性值的时候对应的源数据参数也会连同被修改，但在原数据被修改之前vue就会监听到我</span><br><span class="line">们修改了数据，立马进行解析模板更新页面，这就是ref对象的响应式原理。这里的契约其实就是Object.defineProperty的get( )和<span class="built_in">set</span>( )篇幅有</span><br><span class="line">限我们不对底层核心代码做示范.</span><br><span class="line"></span><br><span class="line">  我们知道了ref函数定义基本类型，下面会讲解reactive函数,该函数参数是对象类型和ref的对象类型参数有着千丝万缕的联系，所以学会reacti</span><br><span class="line">ve函数学会了ref函数存储的对象数据类型也就自然理解了。</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="reactive函数："><a href="#reactive函数：" class="headerlink" title="reactive函数："></a>reactive函数：</h3><p><strong>语法：const xxx = ref (源对象)<br>接受的数据类型：对象类型<br>作用：把参数加工成一个代理对象，全称为proxy对象<br>核心原理：基于Es6的Proxy实现，通过代理操作源对象，相比于reactive定义的浅层次响应式数据对象，reactive定义的是更深层次的响应式数据对象</strong></p>
<hr>
<h5 id="reactive对于对象类型的参数"><a href="#reactive对于对象类型的参数" class="headerlink" title="reactive对于对象类型的参数"></a>reactive对于对象类型的参数</h5><ul>
<li><h6 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;Person.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>薪水：&#123;&#123;Person.job.salary&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p =&#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;Ben&#x27;</span>,</span><br><span class="line">      <span class="attr">job</span>:&#123;</span><br><span class="line">        <span class="attr">salary</span>:<span class="string">&#x27;30k&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> Person =reactive(p)</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      Person</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这里不同于上面的ref函数，参数是一个对象类型的数据，那么对于接受返回值的Person对象也会和上面的ref对象一样都是把数据对应到value属性上吗？</span><br><span class="line">带着这个疑问打印一下Person对象</span><br><span class="line"></span><br><span class="line"><span class="built_in">Proxy</span></span><br><span class="line">[[Handler]]: <span class="built_in">Object</span></span><br><span class="line">[[Target]]: <span class="built_in">Object</span></span><br><span class="line"><span class="attr">job</span>: &#123;<span class="attr">salary</span>: <span class="string">&quot;30k&quot;</span>&#125;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;Ben&quot;</span></span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line">[[IsRevoked]]: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">我们发现Person对象身上并没有value属性并且Person对象是一个proxy类型的对象，这里我们可以理解为Person是一个加强版的p对象，对于p来说Person是一个代理对象，所以我们可以</span><br><span class="line">直接访问到自身的属性，而不是和ref函数一样把数据对应到value属性上，所以我们<span class="keyword">return</span>出去的Person对象可以直接放在模板里读取属性</span><br></pre></td></tr></table></figure></li>
<li><h6 id="响应式原理-1"><a href="#响应式原理-1" class="headerlink" title="响应式原理"></a>响应式原理</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   reactive的响应式是更加“深层次”的，底层依赖于ES6中的Proxy实现，用reactive函数加工出来的对象都是Proxy对象，无论原数据对象里面有多少层对象他们都会被加工成Proxy</span><br><span class="line">类型对象(深层次)。它的响应式核心思想和ref是大同小异的，这里我们定义的Person对象来代理p对象，二者也会建立“契约”，我们在把Person对象<span class="built_in">return</span>出去</span><br><span class="line">后在我们操作修改Person对象的数据时，在原对象数据改变之前Vue都会监听到这一举动并且同时解析模板、更新页面。</span><br></pre></td></tr></table></figure>

<hr>
</li>
</ul>
<h5 id="Ref函数对于对象类型的参数"><a href="#Ref函数对于对象类型的参数" class="headerlink" title="Ref函数对于对象类型的参数"></a>Ref函数对于对象类型的参数</h5><p>说到这里大家会有个疑问，ref定义对象类型的数据和这个reactive函数有什么关系呢？</p>
<p>   ref对象只能去操作浅层次的数据，把基本数据类型当做自己的属性值，如果ref函数的参数是对象这种深层次的数据类型时它会求助一个人，这个人不是别人正是reactive函数，在底层Vue会把对象参数通过reactive函数加工成一个Proxy代理对象放到ref的value属性上</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;Person.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>薪水：&#123;&#123;Person.job.salary&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;reactive,ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p =&#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;Ben&#x27;</span>,</span><br><span class="line">      <span class="attr">job</span>:&#123;</span><br><span class="line">        <span class="attr">salary</span>:<span class="string">&#x27;30k&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> Person =ref(p)</span><br><span class="line">    <span class="built_in">console</span>.log(Person)</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      Person</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印Person对象的结果：</span><br><span class="line"></span><br><span class="line">RefImpl &#123;<span class="attr">_shallow</span>: <span class="literal">false</span>, <span class="attr">__v_isRef</span>: <span class="literal">true</span>, <span class="attr">_rawValue</span>: &#123;…&#125;, <span class="attr">_value</span>: <span class="built_in">Proxy</span>&#125;</span><br><span class="line"><span class="attr">__v_isRef</span>: <span class="literal">true</span></span><br><span class="line"><span class="attr">_rawValue</span>: &#123;<span class="attr">name</span>: <span class="string">&quot;Ben&quot;</span>, <span class="attr">job</span>: &#123;…&#125;&#125;</span><br><span class="line"><span class="attr">_shallow</span>: <span class="literal">false</span></span><br><span class="line"><span class="attr">_value</span>: <span class="built_in">Proxy</span> &#123;<span class="attr">name</span>: <span class="string">&quot;Ben&quot;</span>, <span class="attr">job</span>: &#123;…&#125;&#125;</span><br><span class="line"><span class="attr">value</span>: <span class="built_in">Proxy</span></span><br><span class="line">[[Handler]]: <span class="built_in">Object</span></span><br><span class="line">[[Target]]: <span class="built_in">Object</span></span><br><span class="line"><span class="attr">job</span>: &#123;<span class="attr">salary</span>: <span class="string">&quot;30k&quot;</span>&#125;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;Ben&quot;</span></span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line">[[IsRevoked]]: <span class="literal">false</span></span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line">我们可以很清楚的看到，value属性下对应的正是给p原数据对象加工生成<span class="built_in">Proxy</span>对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.存储类型：ref对象可以接受基本数据类型得数据也可以接受对象类型的数据，而reactive只可以接受对象类型的数据</span><br><span class="line"></span><br><span class="line">2.响应式：相比于ref对象reactive函数是更深层次的，ref函数参数为对象类型时依赖的也是reactive函数</span><br><span class="line"></span><br><span class="line">3.用法：Proxy代理对象的数据键值对是和原数据对象的键值对一一对应的，在使用时可以直接使用 对象(接受返回值的对象).键名 的形式，ref对象会把数据参数对应到自己</span><br><span class="line"></span><br><span class="line">value属性上，在模板里我们可以直接省略.value的形式，这看起来好像是“把源数据赋值给了ref类型的变量，可以直接在模板上使用这个ref类型的变量”</span><br><span class="line"></span><br><span class="line">4.响应式原理：ref的响应式原理是依赖于Object.defineProperty( )的get( )和<span class="built_in">set</span>( )而reactive的响应式原理是依赖于ES6中的Proxy。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>关于Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue_Music练习项目总结</title>
    <url>/2021/09/16/Vue_Music%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h4><table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">首页推荐</td>
<td align="center">首页顶部为轮播图下方内容区域为歌单推荐部分</td>
</tr>
<tr>
<td align="center">歌手</td>
<td align="center">包括各种分类歌手乐队可以选择</td>
</tr>
<tr>
<td align="center">歌单详情</td>
<td align="center">各个歌单在点击后进入歌单详情页面</td>
</tr>
<tr>
<td align="center">rank榜</td>
<td align="center">各类排行榜</td>
</tr>
<tr>
<td align="center">主题换肤</td>
<td align="center">供喜欢样式选择</td>
</tr>
<tr>
<td align="center">搜索</td>
<td align="center">根据歌曲/歌手相关信息进行搜索</td>
</tr>
<tr>
<td align="center">歌曲播放模式</td>
<td align="center">顺序播放、单曲循环、随机播放</td>
</tr>
<tr>
<td align="center">关于</td>
<td align="center">相关版本信息</td>
</tr>
</tbody></table>
<h4 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="https://github.com/Mr-programming/vue_music">https://github.com/Mr-programming/vue_music</a></p>
<p><a href="https://github.com/xieyezi/vueMusic">原项目地址</a></p>
<h4 id="项目思路"><a href="#项目思路" class="headerlink" title="项目思路"></a>项目思路</h4><p>主界面分为 recommend首页推荐 ，singer歌手选择，rank排行榜，搜索界面，歌单详情，播放界面</p>
<p>关于路由跳转采用路由懒加载的形式，图片展示采用v-lazy属性，路由跳转完毕页面等待加载时展示loading组件(展示一个gif动态图)</p>
<h5 id="首页推荐"><a href="#首页推荐" class="headerlink" title="首页推荐"></a>首页推荐</h5><p>首页推荐和歌手选择以及rank榜模块的整体思路类似，在created钩子中就执行加载资源函数，再将歌单对象数组中的各个歌单对象展示到相应位置，包括图片名称。</p>
<h5 id="子路由模块"><a href="#子路由模块" class="headerlink" title="子路由模块"></a>子路由模块</h5><p>这里给每一个组件(首页推荐和歌手选择以及rank榜)都添加子路由，在点击对应的歌单对象后都会执行两个函数，第一个向vuex中传入歌单对象，第二个函数跳转路由。子组件此时会从vuex中拿到对象同时根据歌单id请求歌曲列表</p>
<p>每个子路由组件中都会有一对公用的父子组件来展示歌单详情列表，这里子路由组件只起到请求资源的作用，它会把通过歌单对象请求的歌单信息和歌曲列表传递给这对父子组件，其中父组件展示歌单图片和名字，子组件展歌曲列表</p>
<h5 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h5><p>关于搜索模块，内部嵌套两个子组件，一个是搜索框区域search-box，一个是搜索结果区域suggest，在搜索模块本身created钩子中加载热门搜索关键字，一旦搜索区域有内容输入关键字部分则会隐藏。</p>
<p>在search-box组件中会绑定自定义事件 ，该组件会监听输入内容然后触发自定义事件，从而父组件搜索模块会拿到输入结果，这里触发自定义函数外包裹了节流函数，防止监听到输入一个字符就立马触发自定义事件函数</p>
<p>在搜索模块拿到搜索区域的内容时 会把这个字符串传递给suggest去请求搜索结果并展示</p>
<h5 id="播放模块"><a href="#播放模块" class="headerlink" title="播放模块"></a>播放模块</h5><p>关于播放歌曲组件player ，可以控制是否全屏(默认为全屏)，在通过歌单详情列表点击某个歌曲时，会把这个歌曲列表和被点击歌曲的索引值传到vuex中，歌曲列表传到顺序列表和播放列表(顺序列表是原封不动的传递，播放列表会根据当前已选择的播放模式来判断是否洗牌)，player组件是根据播放列表中是否有内容来展示的，播放器播放的歌曲是通过mapGetters拿到当前播放列表数组中指定索引的歌曲对象。在搜索歌曲中 点歌曲会往播放列表和顺序列表中插队，索引重新指向当前点击歌曲。</p>
<h5 id="当前播放列表"><a href="#当前播放列表" class="headerlink" title="当前播放列表"></a>当前播放列表</h5><p>在播放组件全屏时候可以展示当前播放列表，每一个歌曲都可以从播放列表删除</p>
<h5 id="关于切换歌曲"><a href="#关于切换歌曲" class="headerlink" title="关于切换歌曲"></a>关于切换歌曲</h5><p>关于切换歌曲，切换歌曲只需改变播放列表索引值即可。</p>
<h5 id="关于切换模式"><a href="#关于切换模式" class="headerlink" title="关于切换模式"></a>关于切换模式</h5><p>关于切换模式，切换模式有三种：0(顺序播放)、1(单曲循环)、2(随机播放) 。在点击顺序播放时会把原本的顺序列表赋给播放列表(当前播放歌曲索引要重新搜索确保，确保当前播放的歌曲是不变的)，随机播放是把当前播放列表洗牌，后续同上。</p>
<h5 id="关于主题换肤"><a href="#关于主题换肤" class="headerlink" title="关于主题换肤"></a>关于主题换肤</h5><p>关于主题换肤theme：同样是0,1,2三种 默认为0，在选择之后所有相关页面都会改变颜色(通过vuex)</p>
<h5 id="vuex-中的state"><a href="#vuex-中的state" class="headerlink" title="vuex 中的state"></a>vuex 中的state</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    <span class="attr">theme</span>: <span class="number">0</span>, <span class="comment">//主题颜色 默认值为0</span></span><br><span class="line">    <span class="attr">disc</span>: &#123;&#125;, <span class="comment">//歌单对象</span></span><br><span class="line">    <span class="attr">singer</span>: &#123;&#125;, <span class="comment">//歌手对象(和歌单对象类似)</span></span><br><span class="line">    <span class="attr">rank</span>: &#123;&#125;, <span class="comment">//榜单对象(同上)</span></span><br><span class="line">    <span class="attr">sequenceList</span>: [], <span class="comment">//顺序列表</span></span><br><span class="line">    <span class="attr">playList</span>: [], <span class="comment">//当前播放列表</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="number">0</span>, <span class="comment">//播放模式(默认0顺序播放 1单曲 2随机)</span></span><br><span class="line">    <span class="attr">playing</span>: <span class="literal">false</span>, <span class="comment">//播放状态</span></span><br><span class="line">    <span class="attr">fullScreen</span>: <span class="literal">false</span>, <span class="comment">//是否全屏</span></span><br><span class="line">    <span class="attr">currentIndex</span>: -<span class="number">1</span>, <span class="comment">//当前播放歌曲的索引,</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> state;</span><br></pre></td></tr></table></figure>



<h5 id="App根组件的模板"><a href="#App根组件的模板" class="headerlink" title="App根组件的模板"></a>App根组件的模板</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;App_Top&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Mhead</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Tab</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;AppContent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">player</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h5 id="洗牌函数"><a href="#洗牌函数" class="headerlink" title="洗牌函数"></a>洗牌函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//洗牌函数的辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomInt</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//floor为向下取整</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>) + min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//洗牌函数,打乱歌曲顺序</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _arr = arr.slice();</span><br><span class="line">    <span class="comment">//保留arr,制作一个副本</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = getRandomInt(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">let</span> temp = _arr[i];</span><br><span class="line">        _arr[i] = _arr[j];</span><br><span class="line">        _arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//截流函数 防止输入一个字符就去请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>关于Vue</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>var、let、const关键字的详细解读</title>
    <url>/2021/09/17/var%E3%80%81let%E3%80%81const%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h2><h4 id="作用：后接变量名，用来定义变量"><a href="#作用：后接变量名，用来定义变量" class="headerlink" title="作用：后接变量名，用来定义变量"></a>作用：后接变量名，用来定义变量</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num</span><br></pre></td></tr></table></figure>

<p>这里通过var关键字定义了一个num变量，我们没有给num初始化，此时num的值为undifined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str =<span class="string">&quot;kobe&quot;</span></span><br><span class="line">str=<span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>这里通过var关键字定义了一个保存“kobe”字符串值的 变量str，str的数据类型不是被规定死的，第二行的代码改变了存储值得同时改变了数据类型(改变类型是不推荐的)</p>
<h4 id="声明范围-函数作用域"><a href="#声明范围-函数作用域" class="headerlink" title="声明范围(函数作用域)"></a>声明范围(函数作用域)</h4><ul>
<li>全局作用域下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello,word&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str)</span><br><span class="line">&#125;</span><br><span class="line">test() <span class="comment">//hello ,world</span></span><br></pre></td></tr></table></figure>

<p>在全局作用域下通过var关键字定义的str变量为全局变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.num1, <span class="built_in">window</span>.num2)	<span class="comment">//1，undefined</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.num1, <span class="built_in">window</span>.num2)	<span class="comment">//1,2</span></span><br></pre></td></tr></table></figure>

<p>这里要注意使用var全局声明的变量会成为window对象的属性</p>
<ul>
<li>函数体内：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> str=<span class="string">&quot;hello, world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str)    <span class="comment">//报错！</span></span><br></pre></td></tr></table></figure>

<p>在函数体内通过var关键字定义str变量，函数被调用时会创建这个变量并给其赋值，同样在函数被执行完毕后变量被销毁。也就是说这个变量只在函数作用域内有效，在函数体外部我们是访问不到的。</p>
<ul>
<li>函数体内省略var关键字</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test()</span><br><span class="line"><span class="built_in">console</span>.log(str)  <span class="comment">//hello, world</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    str = <span class="string">&quot;hello,word&quot;</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>同样是在函数体内定义，不同的是省略了var关键字，test函数被调用时(只要被调用一次)就会创建全局变量str，该变量和在直接全局作用域下定义的一样都会成为window的属性</p>
<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><ul>
<li>例1</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str)    <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello,word&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str) 	<span class="comment">//hello, world</span></span><br></pre></td></tr></table></figure>

<p>这里不会报错是相当于执行了如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str</span><br><span class="line"><span class="built_in">console</span>.log(str)	<span class="comment">//undefined</span></span><br><span class="line">str=<span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str)	<span class="comment">//hello, world</span></span><br></pre></td></tr></table></figure>

<ul>
<li>例2</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(num)	<span class="comment">//2</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(num)	<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>相当于执行了如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num</span><br><span class="line">num=<span class="number">1</span></span><br><span class="line">num=<span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(num)	<span class="comment">//2</span></span><br><span class="line">num=<span class="number">3</span></span><br><span class="line">num=<span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(num)	<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>这就是var关键字存在的变量“提升”，也就是把所有变量声明拉倒作用域的顶部。</p>
<hr>
<h2 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h2><p>let关键字和var关键字的作用类似，不过相比于var，let显得更加的严谨，let关键字不存在“变量提升”，let关键声明的作用域范围是块作用域而var关键字是函数作用域</p>
<h4 id="作用：后接变量名，定义变量"><a href="#作用：后接变量名，定义变量" class="headerlink" title="作用：后接变量名，定义变量"></a>作用：后接变量名，定义变量</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str</span><br><span class="line">str = <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(str)	<span class="comment">//123</span></span><br><span class="line">str = <span class="string">&quot;kobe&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str)	<span class="comment">//kobe</span></span><br></pre></td></tr></table></figure>

<h4 id="声明范围-块级作用域"><a href="#声明范围-块级作用域" class="headerlink" title="声明范围(块级作用域)"></a>声明范围(块级作用域)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num)	<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(num)	<span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num)	<span class="comment">//报错！</span></span><br></pre></td></tr></table></figure>

<p>正如开头所说的let关键字不同于var关键字 他的声明范围为块级作用域，在作用域外是访问不到该变量的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> num=<span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.lgo(num)	<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.log(num)	<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> num=<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> num=<span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.log(num)	<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于let关键字在同一块级作用域中，相同标识符会报错</p>
<p>与var关键字不同 ，let关键字在全局作用域声明的变量不会成为window对象的属性</p>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>相比于var关键字，let声明的变量不会在作用域中被提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(num)	<span class="comment">//报错！ 这里不会和var一样打印undefined</span></span><br><span class="line"><span class="keyword">let</span> num=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在num被声明前执行的一瞬间成为“暂时性死区”</p>
<hr>
<h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)		<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>通过var关键字定义的迭代变量会渗透到循环体外部</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)		<span class="comment">//报错！</span></span><br></pre></td></tr></table></figure>

<p>迭代变量的作用域是循环体这个块级作用域，let关键字定义的变量范围正是块级作用域，所以外部访问会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(i)&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>加了定时器函数后打印结果变了，这是因为在退出循环时迭代变量保存的是导致循环退出的值：5，在之后的执行超时函数时所有的i都是同一个值：5</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(i)&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果0 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<p>这是因为后台会为个迭代循环声明一个新的迭代变量，他们都是互相独立的，每一个超时函数时打印的都是不同的变量实例</p>
<hr>
<h2 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h2><p>const关键字和let是类似的，唯一 一个重要区别是const关键字声明变量时必须初始化，并且在修改const定义的变量时会报错(这里指的是修改内存地址),在修改一个对象内部的一个属性时是不会报错的</p>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈JS七种数据类型</title>
    <url>/2021/09/18/%E6%B5%85%E8%B0%88JS%E4%B8%83%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="6种简单数据类型"><a href="#6种简单数据类型" class="headerlink" title="6种简单数据类型"></a>6种简单数据类型</h3><h4 id="undefined类型"><a href="#undefined类型" class="headerlink" title="undefined类型"></a>undefined类型</h4><p>undefined类型只有一个值，就是特殊值undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str</span><br><span class="line"><span class="built_in">console</span>.log(str)	<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(str===<span class="literal">undefined</span>)	<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str)		<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>当我们声明一个变量并没有对其初始化赋值时，这个变量保存的值就是undefined值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str</span><br><span class="line"><span class="built_in">console</span>.log(str)	<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(age)	<span class="comment">//报错！ 未定义</span></span><br></pre></td></tr></table></figure>

<p>注意：定义但没有初始化和本身就没有定义是不一样的</p>
<hr>
<h4 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h4><p>Null类型只有一个值，就是特殊值null</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(person)     <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<p>在定义一个保存对象的变量时可以用null值来初始化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person)		<span class="comment">//object</span></span><br></pre></td></tr></table></figure>

<p>null值表示一个空对象指针，所以在用typeof操作符时返回值为object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person				<span class="comment">//person的值为undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(person==<span class="literal">null</span>)		<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person===<span class="literal">null</span>)		<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>undefined值是由null值派生而来的，所以第二行会打印出true</p>
<hr>
<h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h4><p>布尔类型有两个字面值，true和false</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b1=<span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> b2=<span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(b1,b2)	<span class="comment">//true,false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str= <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">if</span>(str)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(str)	<span class="comment">//hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在流程控制语句中其他类型的值会被执行Boolean()转型函数来转换成布尔值，具体原则如下：</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">转换为true的值</th>
<th align="center">转换为false的值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Boolean</td>
<td align="center">true</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">非空字符串</td>
<td align="center">“    ” (空字符串)</td>
</tr>
<tr>
<td align="center">Number</td>
<td align="center">非零数值(包括无穷值)</td>
<td align="center">0、NaN</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center">任意对象</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">Undefined</td>
<td align="center">N/A (不存在)</td>
<td align="center">undefined</td>
</tr>
</tbody></table>
<hr>
<h4 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h4><p>Number类型可以用来表示整数和浮点数</p>
<ul>
<li>整数</li>
</ul>
<p>整数包括八进制，十六进制，最常用的还是十进制整数。</p>
<ul>
<li>浮点数</li>
</ul>
<p>浮点数中必须包含小数点并且小数点后面必须有数字，不然就会被转换成整数，浮点数在内存中使用的内存空间是整数的两倍。</p>
<ul>
<li>特殊值NaN</li>
</ul>
<p>NaN的意思是“不是数值”，表示本来要返回数值的但是操作失败了，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>/<span class="number">0</span>)	<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>/<span class="number">5</span>)	<span class="comment">//NaN	有关NaN的任何操作返回结果都是NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>===<span class="literal">NaN</span>)	<span class="comment">//false  NaN不等于任何值，包括他自己</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>String数据类型表示0或多个16位Unicode字符序列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1= <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> str2= <span class="string">&#x27;my&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str3=<span class="string">`friend`</span></span><br><span class="line"><span class="built_in">console</span>.log(str1,str2,str3)		<span class="comment">//hello，my,friend</span></span><br></pre></td></tr></table></figure>

<p>在定义字符串时可以使用双引号，单引号，反引号，都是合法的</p>
<ul>
<li>字符串是不可改变的</li>
</ul>
<p>字符串一旦创建，值就不能改变。如果要我们要想修改某个变量中的字符串就必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1=<span class="string">&quot;hello&quot;</span></span><br><span class="line">str1+=<span class="string">&quot;,world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1)	<span class="comment">//hello,world   原字符串“hello”会被销毁，打印的是str中保存新的字符串“hello,world”</span></span><br></pre></td></tr></table></figure>

<p>第一行str1被定义为“hello”字符串，但是在执行第二行时后台会给str1分配一个可以容纳11个字符的空间，str1由“hello”和“,world”拼接而成一个新的字符串，原本的两个字符串”hello”和”,world”会被销毁，所以说字符串是不可变的</p>
<ul>
<li>toString()方法</li>
</ul>
<p>作用：返回当前值的字符串等价物(用于数值、布尔值、对象、字符串)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name=<span class="string">&quot;kobe&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(name.toString())	<span class="comment">//字符串“kobe”</span></span><br><span class="line"><span class="keyword">let</span> flag=<span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(flag.toString())	<span class="comment">//字符串“true”</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num=<span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString())	<span class="comment">//字符串“10”</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>))	<span class="comment">//字符串“1010”</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>)))	<span class="comment">//字符串“12”	</span></span><br></pre></td></tr></table></figure>

<p>对于数值调用该方法时可以填入参数，不填参数默认返回的字符串表示的是十进制数值，填参数会反对对应进制数值的字符串表示</p>
<ul>
<li>模板字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">`first line</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	third line`</span></span><br><span class="line"><span class="built_in">console</span>.log(str)	<span class="comment">//first line</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">//	thirst line</span></span><br></pre></td></tr></table></figure>

<p>相对于单引号和双引号不同的是模板字符串是可以保留换行符和空格的</p>
<ul>
<li>向字符串中插值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;num的值为1&#x27;</span>+num)	<span class="comment">//num的值为1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age=<span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`我今年<span class="subst">$&#123;++age&#125;</span>岁`</span>)		<span class="comment">//我今年21岁</span></span><br></pre></td></tr></table></figure>

<p>也可以通过模板字符串采用上面这种写法去向字符串中插值，插入的值都会使用toString()方法转为字符串</p>
<hr>
<h4 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h4><p>symbol是ES6新增的一个原始数据类型，<a href="https://blog.csdn.net/GGGyp/article/details/102924728?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163197068816780274165248%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163197068816780274165248&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-102924728.first_rank_v2_pc_rank_v29&utm_term=symbol&spm=1018.2226.3001.4187">可以看这里</a></p>
<hr>
<h3 id="1种复杂数据类型"><a href="#1种复杂数据类型" class="headerlink" title="1种复杂数据类型"></a>1种复杂数据类型</h3><h4 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h4><p>对象是一组数据和功能的集合，Object(祖宗类)是派生其他对象的基类，Object类型的所有属性和方法在派生对象上同样存在</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure>

<p>可以通过Object类型来“new出”一个实例对象(不推荐)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person=&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">    <span class="attr">salary</span>:<span class="string">&#x27;30k&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个Person对象是一个包含了姓名，薪水，和say方法的集合</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span>, <span class="attr">salary</span>: <span class="string">&quot;30k&quot;</span>, <span class="attr">say</span>: ƒ&#125;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span></span><br><span class="line"><span class="attr">salary</span>: <span class="string">&quot;30k&quot;</span></span><br><span class="line"><span class="attr">say</span>: ƒ say()</span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"><span class="attr">constructor</span>: ƒ <span class="built_in">Object</span>()</span><br><span class="line"><span class="attr">hasOwnProperty</span>: ƒ hasOwnProperty()</span><br><span class="line"><span class="attr">isPrototypeOf</span>: ƒ isPrototypeOf()</span><br><span class="line"><span class="attr">propertyIsEnumerable</span>: ƒ propertyIsEnumerable()</span><br><span class="line"><span class="attr">toLocaleString</span>: ƒ toLocaleString()</span><br><span class="line"><span class="attr">toString</span>: ƒ toString()</span><br><span class="line"><span class="attr">valueOf</span>: ƒ valueOf()</span><br><span class="line"><span class="attr">__defineGetter__</span>: ƒ __defineGetter__()</span><br><span class="line"><span class="attr">__defineSetter__</span>: ƒ __defineSetter__()</span><br><span class="line"><span class="attr">__lookupGetter__</span>: ƒ __lookupGetter__()</span><br><span class="line"><span class="attr">__lookupSetter__</span>: ƒ __lookupSetter__()</span><br><span class="line">get __proto__: ƒ __proto__()</span><br><span class="line">set __proto__: ƒ __proto__()</span><br></pre></td></tr></table></figure>

<p>每个对象实例都会有来自Object的方法和属性(通过原型链)</p>
<ul>
<li>constructor属性</li>
</ul>
<p>属性值为Object()函数，用于创建当前对象的函数</p>
<ul>
<li>hasOwnProperty(peropertyname)</li>
</ul>
<p>用于判断当前对象本身是否具有该属性(不会通过原型链去查找),属性名是字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>))		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>isPrototypeOf(object)</li>
</ul>
<p>用于判断当前对象是否在参数对象的原型链上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">person.__proto__ = p</span><br><span class="line"><span class="built_in">console</span>.log(p.isPrototypeOf(person))	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>propertyIsEnumerable(propertyName)</li>
</ul>
<p>用于判断给定属性是否可以通过for-in来枚举 ，参数同样是字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = &#123;</span><br><span class="line">    arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line">console.log(num.propertyIsEnumerable(<span class="string">&#x27;arr&#x27;</span>))	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>toLocaleString( )</li>
</ul>
<p>返回对象的字符串表示，该字符串反映对象所在的本地化执行环境</p>
<ul>
<li>toString( )</li>
</ul>
<p>返回对象的字符串表示</p>
<ul>
<li>valueOf( )</li>
</ul>
<p>返回对象对应的字符串、数值或布尔值表示</p>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的全等和不全等、等于和不等于</title>
    <url>/2021/09/21/JS%E4%B8%AD%E7%9A%84%E5%85%A8%E7%AD%89%E5%92%8C%E4%B8%8D%E5%85%A8%E7%AD%89%E3%80%81%E7%AD%89%E4%BA%8E%E5%92%8C%E4%B8%8D%E7%AD%89%E4%BA%8E/</url>
    <content><![CDATA[<h2 id="全等和不全等"><a href="#全等和不全等" class="headerlink" title="全等和不全等"></a>全等和不全等</h2><p>全等和不全等比较的是符号两侧的操作数，以全等操作符为例，如果操作数满足全等则返回true，否则返回false。全等和不全等操作符在做比较相等时不会转换操作数，也就是在不转换的前提下直接进行全等或不全等的比较。</p>
<h4 id="全等"><a href="#全等" class="headerlink" title="全等"></a>全等</h4><p>符号：===</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1=<span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="keyword">let</span> str2=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(str1===str2)		<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="不全等"><a href="#不全等" class="headerlink" title="不全等"></a>不全等</h4><p>符号：！==</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1=<span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="keyword">let</span> str2=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(str1!==str2)		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="相等和不相等"><a href="#相等和不相等" class="headerlink" title="相等和不相等"></a>相等和不相等</h2><p>相等和不相等操作符也同样是比较两个操作数，以相等操作符为例，如果两个操作数满足相等则返回true，否则返回false。不过与全等和不全等操作符的区别在于：相等和不相等操作符会先对操作数进行强制类型转换，转后的操作数再进行比较。</p>
<h4 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h4><p>符号：==</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1=<span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="keyword">let</span> str2=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(str1==str2)		<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(str1===str2)	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flag=<span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> num=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(flag==num)		<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(flag===num)		<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="不相等"><a href="#不相等" class="headerlink" title="不相等"></a>不相等</h4><p>符号：! =</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1=<span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="keyword">let</span> str2=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> str3=<span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1!=str2)		<span class="comment">//false   先是类型转换，之后进行比较</span></span><br><span class="line"><span class="built_in">console</span>.log(str1!==str2)	 <span class="comment">//true	  对于全等操作福这两个操作数不进行强制类型转换，自然就不全等	</span></span><br><span class="line"><span class="built_in">console</span>.log(str2!=str3)		<span class="comment">//true	  </span></span><br><span class="line"><span class="built_in">console</span>.log(str2!==str3)	  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h5 id="对于相等和不相等操作符对操作数进行强制类型转换的规则如下："><a href="#对于相等和不相等操作符对操作数进行强制类型转换的规则如下：" class="headerlink" title="对于相等和不相等操作符对操作数进行强制类型转换的规则如下："></a>对于相等和不相等操作符对操作数进行强制类型转换的规则如下：</h5><ul>
<li><p>布尔值会直接转换成数值进行比较：false：0；true：1</p>
</li>
<li><p>字符串遇到数值则会转换为数值再进行比较</p>
</li>
<li><p>对于对象，如果两个操作数都是对象则比较二者是否为同一个对象，如果两个操作数指向同一个对象则返回true，否则返回false。如果其中的一个操作数为对象则会调用valueOf方法取到原始值，之后再进行比较(按照上述规则)</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">&#x27;zhangsan&#x27;</span>)	<span class="comment">//相当于const p=new String(&#x27;zhangsan&#x27;)</span></span><br><span class="line"><span class="built_in">console</span>.log(p.valueOf() == <span class="string">&#x27;zhangsan&#x27;</span>)	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(p == <span class="string">&#x27;zhangsan&#x27;</span>)	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1=&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span>   p2=p1</span><br><span class="line"><span class="built_in">console</span>.log(p1==p2)		<span class="comment">//true</span></span><br><span class="line">p2=&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p1==p2)		<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于null和undefined，null和undefined是相等的，但是无论和谁比较，他们都不会被强转。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>==<span class="literal">undefined</span>)		<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>===<span class="literal">undefined</span>)		<span class="comment">//false		对于全等返回结果依然是false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于NaN，NaN不等于任何值包括他自己。涉及到操作符是NaN的比较，只要是相等操作符则返回false，不相等则返回true</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>==<span class="literal">NaN</span>)	<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>!=<span class="string">&#x27;&#x27;</span>)	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>!=<span class="number">1</span>)	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>!=&#123;&#125;)	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
