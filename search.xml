<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS中的原始值、引用值、按值传递</title>
    <url>/2021/09/20/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E5%80%BC%E3%80%81%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p><img src="/2021/09/20/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E5%80%BC%E3%80%81%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/305316cf616248d0bcf815df9493e0db.png" alt="305316cf616248d0bcf815df9493e0db"></p>
<p><strong><p style="color:red">对于JS中的变量只存储两种类型的值，原始值和引用值。</p></strong></p>
<h4 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h4><p><strong>原始值就是最简单的数据，也就是几种基本数据类型的值。原始值存储在栈内存中，通过变量可以直接访问到，是按值访问的。</strong></p>
<p>为什么存储在栈中呢？<br>因为原始值占据空间大小固定，所以存储在栈内存中，方便快速查找。</p>
<h5 id="对于原始值的复制值"><a href="#对于原始值的复制值" class="headerlink" title="对于原始值的复制值"></a>对于原始值的复制值</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1=<span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> num2=num1</span><br><span class="line"><span class="built_in">console</span>.log(++num1)		<span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log(num2)		<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>第一行num1变量存储数值5，第二行num2初始化为num1，该变量也同样存储数值5。但是这两个变量中的数值5是完全独立的，两个变量可以独立使用，互不干扰。如下图：</p>
<p><img src="/2021/09/20/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E5%80%BC%E3%80%81%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/liucheng1-1.png"></p>
<center>图1-1 num1初始化</center>

<p><img src="/2021/09/20/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E5%80%BC%E3%80%81%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/liucheng1-2.png"></p>
<center>图1-2 num2初始化</center>

<h4 id="引用值"><a href="#引用值" class="headerlink" title="引用值"></a>引用值</h4><p>引用值是储存在堆内存中的对象，在JS中不允许我们直接去访问该内存位置，所以保存在变量中的值为指针，这个指针指向了堆内存中的对象，我们并没有直接去操作对象，而是通过保存在变量中的指针去间接的操作对象，所以是按引用访问的。<br>保存在变量中的值为该对象在对堆内存中的位置。这个值大小固定，存储在栈内存中。如图：</p>
<p><img src="/2021/09/20/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E5%80%BC%E3%80%81%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/3c9737054b0741eb8ad210a3c9d5ec44.png" alt="3c9737054b0741eb8ad210a3c9d5ec44"></p>
<h5 id="对于引用值的复制值"><a href="#对于引用值的复制值" class="headerlink" title="对于引用值的复制值"></a>对于引用值的复制值</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1=<span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="keyword">let</span> obj2=obj1</span><br><span class="line">obj1.num=<span class="number">1</span>		<span class="comment">//为obj1对象添加num属性属性值为1</span></span><br><span class="line">consol.log(obj2.num)	<span class="comment">//1		通过obj2也可以访问num属性，这是为什么呢？</span></span><br></pre></td></tr></table></figure>

<p>在第一行中我们为obj1“new”出了一个新的实例对象，在第二行中执行了一个复制值的操作，虽然有值的复制但是并没有在内存中重新开辟新的空间，也就是说这一步复制的值就相当于一个指针，该指针指向内存中的对象(obj1所指向的对象)。这样obj2和obj1通过指针指向同一内存地址，无论哪一个改变了，内存中的对象都会改变。如下图：</p>
<p><img src="/2021/09/20/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E5%80%BC%E3%80%81%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/liucheng2-1.png"></p>
<center>图2-1 执行复制值之前</center>

<p><img src="/2021/09/20/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E5%80%BC%E3%80%81%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/liucheng2-2.png"></p>
<center>图2-2执行复制值之后</center>

<h4 id="函数传参-按值传递"><a href="#函数传参-按值传递" class="headerlink" title="函数传参(按值传递)"></a>函数传参(按值传递)</h4><p>JS中所有函数传参都是按值传递的。也就是说传递的参数会被复制到函数内部的参数中，就像两个变量进行复制操作一样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ++num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> n=<span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(add(n))		<span class="comment">//11</span></span><br><span class="line"><span class="built_in">console</span>.log(n)		<span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p>我们可以发现对于原始值(基本数据类型)传参(按值传递)，函数内部的操作不会影响到外部，这很好理解。正如开头说的，传参相当于执行了复制操作，对于原始值复制值两个变量是完全独立的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPerson</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">	obj.name=<span class="string">&quot;kobe&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p=<span class="keyword">new</span> <span class="built_in">Object</span>()		<span class="comment">//创建一个p对象</span></span><br><span class="line">setPerson(p)</span><br><span class="line"><span class="built_in">console</span>.log(p.name)		<span class="comment">//kobe</span></span><br></pre></td></tr></table></figure>

<p>对于引用值传参(按值传递)，函数内部的操作会影响到外部，很多人认为这就是按引用传递其实是不对的。看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPerson</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">	obj.age=<span class="number">20</span></span><br><span class="line">    obj=<span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    obj.age=<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p =<span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">setPerson(p)		</span><br><span class="line"><span class="built_in">console</span>.log(p.age)		<span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p>如果对于引用值函数传参是按引用传递的话，在函数体内部obj指向了一个新的对象，并且为对象添加age属性，属性值为22 ，外部p也应指向新对象并且age也应该为22，但是结果确是20,足以说明这并不是按引用传递而是按值传递。</p>
<p>在函数体内的过程：</p>
<p>按值传递实参p会将指针复制给实参obj，此时他们共同指向存放在全局作用域堆内存中的对象，所以添加属性age并为其赋值外部实参也会产生相应的变化</p>
<p><img src="/2021/09/20/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E5%80%BC%E3%80%81%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/liucheng3-1.png"></p>
<center>图3-1 传递参数</center>

<p>obj在函数内部被重写，他的指针指向了本地对象，而原本的实参p是不受影响的，这个本地对象在函数执行之后会被销毁。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>原始值大小固定，保存在栈内存中</li>
<li>引用值是对象，保存在堆内存中</li>
<li>保存引用值的变量实际上<strong>只</strong>保存了指向该对象的指针，并不是保存变量本身</li>
<li>复制原始值（从一个变量到另一个变量）是创建了一个新值，二者是并无关系的</li>
<li>复制引用值（从一个变量到另一个变量）<strong>只</strong>复制了指针，所以二者指向了同一个对象</li>
</ul>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2组件间通信---全局事件总线</title>
    <url>/2021/09/04/Vue2%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1-%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><p>实现任意组件间通信</p>
<hr>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>相对于接受者和传递者来说全局事件总线相当于一个第三人，接受者会给全局事件总线绑定自定义事件，回调在自己的methods中。传递者去触发这个第三人绑定的自定义事件，回掉参数就是要传递的数据、</p>
<hr>
<h3 id="安装全局事件总线："><a href="#安装全局事件总线：" class="headerlink" title="安装全局事件总线："></a>安装全局事件总线：</h3><h5 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.__proto__.$bus = <span class="built_in">this</span>;</span><br><span class="line">        <span class="comment">// Vue.prototype.$bus = this</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这里的$bus就是我们所说的“第三人”，我们给Vue实例的原型对象添加$bus属性，属性值为一个Vue实例(我们当前new出来的实例对象)，这样做的目的就是为了让所有的组件实例对象都可以在自己的原型对象上找到找到这个$bus。</p>
<p>这里存在一个关系：VueComponent.prototype.__ proto __ === Vue.prototype</p>
<p>说白了就是给Vue的原型对象上添加$bus其他的组件实例都可以通过原型链去找到这个属性</p>
<h5 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h5><p>当然，我们还可以另外定义一个js文件创建一个Vue实例对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">expotr <span class="keyword">default</span> <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure>

<p>这一种方式我们要在使用他的组建中引入，对于以上两种方式都可以采用，它们都是找一个”第三人“</p>
<hr>
<h3 id="使用全局事件总线："><a href="#使用全局事件总线：" class="headerlink" title="使用全局事件总线："></a>使用全局事件总线：</h3><p>全部以第一种安装方式为例：</p>
<h5 id="接收数据："><a href="#接收数据：" class="headerlink" title="接收数据："></a>接收数据：</h5><p>brother1组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Brother1&#x27;</span>,</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$bus.$on(<span class="string">&#x27;showMsg&#x27;</span>,<span class="built_in">this</span>.show)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="传递数据："><a href="#传递数据：" class="headerlink" title="传递数据："></a>传递数据：</h5><p>brother2组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Brother2&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$bus.$emit(<span class="string">&#x27;showMsg&#x27;</span>,<span class="string">&#x27;我是Brother2&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>brother3组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Brother3&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$bus.$emit(<span class="string">&#x27;showMsg&#x27;</span>,<span class="string">&#x27;我是Brother3&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>App组件的模板：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Brother1</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Brother2</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Brother3</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">我是Brother2</span><br><span class="line">我是Brother3</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>相比于props和子传父自定义事件全局事件总线可以做到任意键组件间通信，区别于子传父自定义事件的父组件给子组件绑定自定义事件，全局事件总线的方式是找了一个“第三人”，大家都可以为这个第三人去绑定自定义事件，也可以去触发这个自定义事件来达到任意组件间通信的目的。</p>
]]></content>
      <categories>
        <category>关于Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2组件间通信---子传父值自定义事件</title>
    <url>/2021/09/03/Vue2%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1---%E5%AD%90%E4%BC%A0%E7%88%B6%E5%80%BC%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><p>父组件可以接受到子组件传递的数据，适用于组件间通信。</p>
<hr>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>子组件要给父组件传递数据，此时要在父组件中给子组件绑定一个自定义事件，回调写在父组件中。那么触发这个自定义事件的就是子组件，传递的参数就是子组件要给父组件传递的数据。</p>
<hr>
<h3 id="绑定自定义事件的两种方式："><a href="#绑定自定义事件的两种方式：" class="headerlink" title="绑定自定义事件的两种方式："></a>绑定自定义事件的两种方式：</h3><ul>
<li><h5 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a>第一种方式：</h5></li>
</ul>
<p>父组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Son</span> @<span class="attr">show</span>=<span class="string">&quot;showName&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Son <span class="keyword">from</span> <span class="string">&#x27;./Son.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Father&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">showName</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">components</span>:&#123;</span><br><span class="line">    Son</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Son&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$emit(<span class="string">&#x27;show&#x27;</span>,<span class="string">&quot;Son子组件&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">控制台结果：</span><br><span class="line"></span><br><span class="line">Son子组件</span><br></pre></td></tr></table></figure>



<ul>
<li><h5 id="第二种方式："><a href="#第二种方式：" class="headerlink" title="第二种方式："></a>第二种方式：</h5></li>
</ul>
<p>父组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Son</span> <span class="attr">ref</span>=<span class="string">&quot;MySon&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> Son <span class="keyword">from</span> <span class="string">&#x27;./Son.vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>:<span class="string">&#x27;Father&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">ShowName</span>(<span class="params">name</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">console</span>.log(name)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">this</span>.$refs.MySon.$on(<span class="string">&#x27;show&#x27;</span>,<span class="built_in">this</span>.ShowName)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    Son</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toFather&quot;</span>&gt;</span>为Father传值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>:<span class="string">&#x27;Son&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">toFather</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;show&#x27;</span>,<span class="string">&quot;Son子组件&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">控制台结果：</span><br><span class="line"></span><br><span class="line">Son子组件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="区别-小坑-："><a href="#区别-小坑-：" class="headerlink" title="区别(小坑)："></a>区别(小坑)：</h3><p>两种方式的目的都是为了子传父值，不过在这里需要注意的是第二种方式在为子组件绑定自定义事件的时机与第一种方式不同，第二种是在整个页面挂载之后对子组件绑定自定义事件，而Vue的执行机制是子组件比父组件先进行渲染，也就是说子组件都已经渲染完毕了之后我们才给它绑定自定义事件，所以子组件中触发自定义事件的函数不可以在mounted钩子中执行。通俗点说就是子组件比父组件先进行渲染，子组件的mounted函数比父组件的先执行，在执行的时候父组件的自定义事件还没有绑定(查无此人)。所以在示例中对于第二种方式我们在子组件中用按钮去触发自定义事件。</p>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><ol>
<li> 我们最好在组件销毁之前对自定义事件进行解绑，this.$off (‘自定义事件’), 这一过程可以在beforeDestroy钩子中执行</li>
<li> 对于绑定原生DOM事件也可以用native修饰符修饰  如： @click.native=”…” 这样click事件就变成了原生Dom事件不会被当做自定义事件执行。</li>
<li> 注意点：对于第二种方式绑定自定义事件的回调函数要么写成命名函数的方式到methods中，要么写成箭头函数的形式，否则this指向不是组件实例。</li>
</ol>
]]></content>
      <categories>
        <category>关于Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2组件间通信——父传子值props</title>
    <url>/2021/09/02/Vue2%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1---%E7%88%B6%E4%BC%A0%E5%AD%90%E5%80%BCprops/</url>
    <content><![CDATA[<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><p>子组件可以接收到父组件传递的数据信息，适用于组件间通信，对于父传子props配置相相对来说是较为方便的</p>
<hr>
<h3 id="传递方式："><a href="#传递方式：" class="headerlink" title="传递方式："></a>传递方式：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Son</span> <span class="attr">:msg</span>=<span class="string">&quot;Str&quot;</span> <span class="attr">:Job</span>=<span class="string">&#x27;job&#x27;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> Son <span class="keyword">from</span> <span class="string">&#x27;./Son.vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>:<span class="string">&#x27;Father&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">Str</span>:<span class="string">&#x27;hello&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">job</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">salary</span>:<span class="string">&#x27;30k&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    Son</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">传递方式很简单，只需在子组件中传入父组件想传递的信息即可，msg和Job是我们的自定义写法，不过要注意的是在前面要加v-bind指令，</span><br><span class="line">不然“ ”中的值会被当做字符串传入Son组件中</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="接受方式："><a href="#接受方式：" class="headerlink" title="接受方式："></a>接受方式：</h3><ul>
<li><h5 id="数组类型的接收方式"><a href="#数组类型的接收方式" class="headerlink" title="数组类型的接收方式"></a>数组类型的接收方式</h5></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Son&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>:[<span class="string">&#x27;msg&#x27;</span>,<span class="string">&#x27;Job&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.Job)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">__ob__</span>: Observer&#125;</span><br><span class="line"><span class="attr">salary</span>: <span class="string">&quot;30k&quot;</span></span><br><span class="line"><span class="attr">__ob__</span>: Observer &#123;<span class="attr">value</span>: &#123;…&#125;, <span class="attr">dep</span>: Dep, <span class="attr">vmCount</span>: <span class="number">0</span>&#125;</span><br><span class="line">get salary: ƒ reactiveGetter()</span><br><span class="line">set salary: ƒ reactiveSetter(newVal)</span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line">用数组的形式来接收传递过来的信息看起来起来像是傻瓜形式的接受，因为我们并没有对接受结果做限制。我们可以看到在钩子里可以使用</span><br><span class="line"><span class="built_in">this</span>来拿到数据，所以说传递过来的信息也是在组件实例身上的。</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="带有限制的接收方式"><a href="#带有限制的接收方式" class="headerlink" title="带有限制的接收方式"></a>带有限制的接收方式</h5></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Son&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">props</span>:&#123;</span><br><span class="line">    <span class="attr">msg</span>:&#123;</span><br><span class="line">      <span class="attr">type</span>:<span class="built_in">String</span>,      <span class="comment">//类型</span></span><br><span class="line">      <span class="attr">required</span>:<span class="literal">false</span>,   <span class="comment">//是否必填</span></span><br><span class="line">      <span class="attr">default</span>:<span class="string">&#x27;你好&#x27;</span>     <span class="comment">//默认值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">Job</span>:<span class="built_in">Object</span>			<span class="comment">//简写</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.Job)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">你好</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">__ob__</span>: Observer&#125;</span><br><span class="line"><span class="attr">salary</span>: <span class="string">&quot;30k&quot;</span></span><br><span class="line"><span class="attr">__ob__</span>: Observer &#123;<span class="attr">value</span>: &#123;…&#125;, <span class="attr">dep</span>: Dep, <span class="attr">vmCount</span>: <span class="number">0</span>&#125;</span><br><span class="line">get salary: ƒ reactiveGetter()</span><br><span class="line">set salary: ƒ reactiveSetter(newVal)</span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line">相比于数组类型接收数据，采用配置对象的形式来接收数据可以很好地限制父组件传递过来的数据信息。上面在父组件中并没有传递msg，所以</span><br><span class="line">msg打印出的结果是配置项中的默认值 你好</span><br></pre></td></tr></table></figure>



<p>这里我们可能有个疑问，父向子传递数据之后 子组件会永久存储着传递过来的数据吗？对于不同的父组件呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Father</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Son</span> <span class="attr">:msg</span>=<span class="string">&quot;Str2&quot;</span> <span class="attr">:Job</span>=<span class="string">&quot;myjob&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> Father <span class="keyword">from</span> <span class="string">&#x27;./components/Father.vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> Son <span class="keyword">from</span> <span class="string">&#x27;./components/Son.vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>:<span class="string">&#x27;App&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">Str2</span>:<span class="string">&#x27;world&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">myjob</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">salary</span>:<span class="string">&#x27;10k&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  Father,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  Son</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">你好</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">__ob__</span>: Observer&#125;</span><br><span class="line"><span class="attr">salary</span>: <span class="string">&quot;30k&quot;</span></span><br><span class="line"><span class="attr">__ob__</span>: Observer &#123;<span class="attr">value</span>: &#123;…&#125;, <span class="attr">dep</span>: Dep, <span class="attr">vmCount</span>: <span class="number">0</span>&#125;</span><br><span class="line">get salary: ƒ reactiveGetter()</span><br><span class="line">set salary: ƒ reactiveSetter(newVal)</span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line">world</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">__ob__</span>: Observer&#125;</span><br><span class="line"><span class="attr">salary</span>: <span class="string">&quot;10k&quot;</span></span><br><span class="line"><span class="attr">__ob__</span>: Observer &#123;<span class="attr">value</span>: &#123;…&#125;, <span class="attr">dep</span>: Dep, <span class="attr">vmCount</span>: <span class="number">0</span>&#125;</span><br><span class="line">get salary: ƒ reactiveGetter()</span><br><span class="line">set salary: ƒ reactiveSetter(newVal)</span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​     这里我们在App组件中也向Son组建中传递了相关数据，我们可以看出控制台分别打印了两次 msg和Job 的结果。 很明显Son组件作为子组件对于Faher组件和App组件分别挂载了一次，对应的mounted钩子也分别执行一次，每次打印的信息都是对应父组件传递的相关数据。</p>
]]></content>
      <categories>
        <category>关于Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3中的的ref函数和reactive函数及其浅层次响应式原理</title>
    <url>/2021/08/31/Vue3%E4%B8%AD%E7%9A%84%E7%9A%84ref%E5%87%BD%E6%95%B0%E5%92%8Creactive%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E6%B5%85%E5%B1%82%E6%AC%A1%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>​        </p>
<h3 id="ref函数："><a href="#ref函数：" class="headerlink" title="ref函数："></a>ref函数：</h3><p><strong>语法：const xxx = ref (initValue)<br>接受的数据类型：基本类型，对象类型<br>作用：把参数加工成一个响应式对象，全称为reference对象(我们下面一律简称为ref对象)<br>核心原理：响应式依赖Object.defineProperty( )的get( )和set( )</strong></p>
<hr>
<h5 id="Ref函数对于基本数据类型的参数"><a href="#Ref函数对于基本数据类型的参数" class="headerlink" title="Ref函数对于基本数据类型的参数"></a>Ref函数对于基本数据类型的参数</h5><ul>
<li><h6 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h6></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;Str&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Str =ref(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      Str</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  这里我们定义了一个Str变量来接收ref加工生成的ref对象，我们都知道对象的数据都是以键值对的形式存储的，但是在这里为什么直接把Str给<span class="keyword">return</span>出去，</span><br><span class="line">并且模板里可以直接写Str这个对象呢,我们的源数据呢？带着这个疑问我们来输出一下Str</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Str =ref(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(Str)</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      Str</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">打印结果如下：</span><br><span class="line">RefImpl</span><br><span class="line"><span class="attr">__v_isRef</span>: <span class="literal">true</span></span><br><span class="line"><span class="attr">_rawValue</span>: <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="attr">_shallow</span>: <span class="literal">false</span></span><br><span class="line"><span class="attr">_value</span>: <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="attr">value</span>: <span class="string">&quot;hello&quot;</span></span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line">  在这里我们看到了ref对象身上的一个属性 value,没错，我们存入的值就对应在value属性上，至于为什么直接<span class="keyword">return</span>出是Str而不是Str.value 。是因为Vue帮了我们</span><br><span class="line">一个忙，我们在这里可以简写，<span class="keyword">return</span>出去的Str 就相当于Str.value ，当然 非要写.value的形式也不是不可以。不过这里需要注意的是，在</span><br><span class="line">setup函数中操作Str中的数据不可以简写。</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h6></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   对于基本数据类型说完了它的基本用法，下面我们来说说他的响应式原理，也就是我们为什么非要用一个ref对象来接受数据，而不是直接就定义好一个字符</span><br><span class="line">串‘hello’然后去直接操作这个字符串？</span><br><span class="line"></span><br><span class="line">  对于ref函数，数据参数和它加工生成的ref对象二者存在着某种“契约”，我们把加工好的参数也就是ref对象交出去之后，我们直接操作修改的就是ref</span><br><span class="line">对象上的value属性，因为这个契约的存在，以至于在修改属性值的时候对应的源数据参数也会连同被修改，但在原数据被修改之前vue就会监听到我</span><br><span class="line">们修改了数据，立马进行解析模板更新页面，这就是ref对象的响应式原理。这里的契约其实就是Object.defineProperty的get( )和<span class="built_in">set</span>( )篇幅有</span><br><span class="line">限我们不对底层核心代码做示范.</span><br><span class="line"></span><br><span class="line">  我们知道了ref函数定义基本类型，下面会讲解reactive函数,该函数参数是对象类型和ref的对象类型参数有着千丝万缕的联系，所以学会reacti</span><br><span class="line">ve函数学会了ref函数存储的对象数据类型也就自然理解了。</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="reactive函数："><a href="#reactive函数：" class="headerlink" title="reactive函数："></a>reactive函数：</h3><p><strong>语法：const xxx = ref (源对象)<br>接受的数据类型：对象类型<br>作用：把参数加工成一个代理对象，全称为proxy对象<br>核心原理：基于Es6的Proxy实现，通过代理操作源对象，相比于reactive定义的浅层次响应式数据对象，reactive定义的是更深层次的响应式数据对象</strong></p>
<hr>
<h5 id="reactive对于对象类型的参数"><a href="#reactive对于对象类型的参数" class="headerlink" title="reactive对于对象类型的参数"></a>reactive对于对象类型的参数</h5><ul>
<li><h6 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;Person.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>薪水：&#123;&#123;Person.job.salary&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p =&#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;Ben&#x27;</span>,</span><br><span class="line">      <span class="attr">job</span>:&#123;</span><br><span class="line">        <span class="attr">salary</span>:<span class="string">&#x27;30k&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> Person =reactive(p)</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      Person</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这里不同于上面的ref函数，参数是一个对象类型的数据，那么对于接受返回值的Person对象也会和上面的ref对象一样都是把数据对应到value属性上吗？</span><br><span class="line">带着这个疑问打印一下Person对象</span><br><span class="line"></span><br><span class="line"><span class="built_in">Proxy</span></span><br><span class="line">[[Handler]]: <span class="built_in">Object</span></span><br><span class="line">[[Target]]: <span class="built_in">Object</span></span><br><span class="line"><span class="attr">job</span>: &#123;<span class="attr">salary</span>: <span class="string">&quot;30k&quot;</span>&#125;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;Ben&quot;</span></span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line">[[IsRevoked]]: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">我们发现Person对象身上并没有value属性并且Person对象是一个proxy类型的对象，这里我们可以理解为Person是一个加强版的p对象，对于p来说Person是一个代理对象，所以我们可以</span><br><span class="line">直接访问到自身的属性，而不是和ref函数一样把数据对应到value属性上，所以我们<span class="keyword">return</span>出去的Person对象可以直接放在模板里读取属性</span><br></pre></td></tr></table></figure></li>
<li><h6 id="响应式原理-1"><a href="#响应式原理-1" class="headerlink" title="响应式原理"></a>响应式原理</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   reactive的响应式是更加“深层次”的，底层依赖于ES6中的Proxy实现，用reactive函数加工出来的对象都是Proxy对象，无论原数据对象里面有多少层对象他们都会被加工成Proxy</span><br><span class="line">类型对象(深层次)。它的响应式核心思想和ref是大同小异的，这里我们定义的Person对象来代理p对象，二者也会建立“契约”，我们在把Person对象<span class="built_in">return</span>出去</span><br><span class="line">后在我们操作修改Person对象的数据时，在原对象数据改变之前Vue都会监听到这一举动并且同时解析模板、更新页面。</span><br></pre></td></tr></table></figure>

<hr>
</li>
</ul>
<h5 id="Ref函数对于对象类型的参数"><a href="#Ref函数对于对象类型的参数" class="headerlink" title="Ref函数对于对象类型的参数"></a>Ref函数对于对象类型的参数</h5><p>说到这里大家会有个疑问，ref定义对象类型的数据和这个reactive函数有什么关系呢？</p>
<p>   ref对象只能去操作浅层次的数据，把基本数据类型当做自己的属性值，如果ref函数的参数是对象这种深层次的数据类型时它会求助一个人，这个人不是别人正是reactive函数，在底层Vue会把对象参数通过reactive函数加工成一个Proxy代理对象放到ref的value属性上</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;Person.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>薪水：&#123;&#123;Person.job.salary&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;reactive,ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p =&#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;Ben&#x27;</span>,</span><br><span class="line">      <span class="attr">job</span>:&#123;</span><br><span class="line">        <span class="attr">salary</span>:<span class="string">&#x27;30k&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> Person =ref(p)</span><br><span class="line">    <span class="built_in">console</span>.log(Person)</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      Person</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印Person对象的结果：</span><br><span class="line"></span><br><span class="line">RefImpl &#123;<span class="attr">_shallow</span>: <span class="literal">false</span>, <span class="attr">__v_isRef</span>: <span class="literal">true</span>, <span class="attr">_rawValue</span>: &#123;…&#125;, <span class="attr">_value</span>: <span class="built_in">Proxy</span>&#125;</span><br><span class="line"><span class="attr">__v_isRef</span>: <span class="literal">true</span></span><br><span class="line"><span class="attr">_rawValue</span>: &#123;<span class="attr">name</span>: <span class="string">&quot;Ben&quot;</span>, <span class="attr">job</span>: &#123;…&#125;&#125;</span><br><span class="line"><span class="attr">_shallow</span>: <span class="literal">false</span></span><br><span class="line"><span class="attr">_value</span>: <span class="built_in">Proxy</span> &#123;<span class="attr">name</span>: <span class="string">&quot;Ben&quot;</span>, <span class="attr">job</span>: &#123;…&#125;&#125;</span><br><span class="line"><span class="attr">value</span>: <span class="built_in">Proxy</span></span><br><span class="line">[[Handler]]: <span class="built_in">Object</span></span><br><span class="line">[[Target]]: <span class="built_in">Object</span></span><br><span class="line"><span class="attr">job</span>: &#123;<span class="attr">salary</span>: <span class="string">&quot;30k&quot;</span>&#125;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;Ben&quot;</span></span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line">[[IsRevoked]]: <span class="literal">false</span></span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line">我们可以很清楚的看到，value属性下对应的正是给p原数据对象加工生成<span class="built_in">Proxy</span>对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.存储类型：ref对象可以接受基本数据类型得数据也可以接受对象类型的数据，而reactive只可以接受对象类型的数据</span><br><span class="line"></span><br><span class="line">2.响应式：相比于ref对象reactive函数是更深层次的，ref函数参数为对象类型时依赖的也是reactive函数</span><br><span class="line"></span><br><span class="line">3.用法：Proxy代理对象的数据键值对是和原数据对象的键值对一一对应的，在使用时可以直接使用 对象(接受返回值的对象).键名 的形式，ref对象会把数据参数对应到自己</span><br><span class="line"></span><br><span class="line">value属性上，在模板里我们可以直接省略.value的形式，这看起来好像是“把源数据赋值给了ref类型的变量，可以直接在模板上使用这个ref类型的变量”</span><br><span class="line"></span><br><span class="line">4.响应式原理：ref的响应式原理是依赖于Object.defineProperty( )的get( )和<span class="built_in">set</span>( )而reactive的响应式原理是依赖于ES6中的Proxy。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>关于Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue_Music练习项目总结</title>
    <url>/2021/09/16/Vue_Music%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h4><table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">首页推荐</td>
<td align="center">首页顶部为轮播图下方内容区域为歌单推荐部分</td>
</tr>
<tr>
<td align="center">歌手</td>
<td align="center">包括各种分类歌手乐队可以选择</td>
</tr>
<tr>
<td align="center">歌单详情</td>
<td align="center">各个歌单在点击后进入歌单详情页面</td>
</tr>
<tr>
<td align="center">rank榜</td>
<td align="center">各类排行榜</td>
</tr>
<tr>
<td align="center">主题换肤</td>
<td align="center">供喜欢样式选择</td>
</tr>
<tr>
<td align="center">搜索</td>
<td align="center">根据歌曲/歌手相关信息进行搜索</td>
</tr>
<tr>
<td align="center">歌曲播放模式</td>
<td align="center">顺序播放、单曲循环、随机播放</td>
</tr>
<tr>
<td align="center">关于</td>
<td align="center">相关版本信息</td>
</tr>
</tbody></table>
<h4 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="https://github.com/Mr-programming/vue_music">https://github.com/Mr-programming/vue_music</a></p>
<p><a href="https://github.com/xieyezi/vueMusic">原项目地址</a></p>
<h4 id="项目思路"><a href="#项目思路" class="headerlink" title="项目思路"></a>项目思路</h4><p>主界面分为 recommend首页推荐 ，singer歌手选择，rank排行榜，搜索界面，歌单详情，播放界面</p>
<p>关于路由跳转采用路由懒加载的形式，图片展示采用v-lazy属性，路由跳转完毕页面等待加载时展示loading组件(展示一个gif动态图)</p>
<h5 id="首页推荐"><a href="#首页推荐" class="headerlink" title="首页推荐"></a>首页推荐</h5><p>首页推荐和歌手选择以及rank榜模块的整体思路类似，在created钩子中就执行加载资源函数，再将歌单对象数组中的各个歌单对象展示到相应位置，包括图片名称。</p>
<h5 id="子路由模块"><a href="#子路由模块" class="headerlink" title="子路由模块"></a>子路由模块</h5><p>这里给每一个组件(首页推荐和歌手选择以及rank榜)都添加子路由，在点击对应的歌单对象后都会执行两个函数，第一个向vuex中传入歌单对象，第二个函数跳转路由。子组件此时会从vuex中拿到对象同时根据歌单id请求歌曲列表</p>
<p>每个子路由组件中都会有一对公用的父子组件来展示歌单详情列表，这里子路由组件只起到请求资源的作用，它会把通过歌单对象请求的歌单信息和歌曲列表传递给这对父子组件，其中父组件展示歌单图片和名字，子组件展歌曲列表</p>
<h5 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h5><p>关于搜索模块，内部嵌套两个子组件，一个是搜索框区域search-box，一个是搜索结果区域suggest，在搜索模块本身created钩子中加载热门搜索关键字，一旦搜索区域有内容输入关键字部分则会隐藏。</p>
<p>在search-box组件中会绑定自定义事件 ，该组件会监听输入内容然后触发自定义事件，从而父组件搜索模块会拿到输入结果，这里触发自定义函数外包裹了节流函数，防止监听到输入一个字符就立马触发自定义事件函数</p>
<p>在搜索模块拿到搜索区域的内容时 会把这个字符串传递给suggest去请求搜索结果并展示</p>
<h5 id="播放模块"><a href="#播放模块" class="headerlink" title="播放模块"></a>播放模块</h5><p>关于播放歌曲组件player ，可以控制是否全屏(默认为全屏)，在通过歌单详情列表点击某个歌曲时，会把这个歌曲列表和被点击歌曲的索引值传到vuex中，歌曲列表传到顺序列表和播放列表(顺序列表是原封不动的传递，播放列表会根据当前已选择的播放模式来判断是否洗牌)，player组件是根据播放列表中是否有内容来展示的，播放器播放的歌曲是通过mapGetters拿到当前播放列表数组中指定索引的歌曲对象。在搜索歌曲中 点歌曲会往播放列表和顺序列表中插队，索引重新指向当前点击歌曲。</p>
<h5 id="当前播放列表"><a href="#当前播放列表" class="headerlink" title="当前播放列表"></a>当前播放列表</h5><p>在播放组件全屏时候可以展示当前播放列表，每一个歌曲都可以从播放列表删除</p>
<h5 id="关于切换歌曲"><a href="#关于切换歌曲" class="headerlink" title="关于切换歌曲"></a>关于切换歌曲</h5><p>关于切换歌曲，切换歌曲只需改变播放列表索引值即可。</p>
<h5 id="关于切换模式"><a href="#关于切换模式" class="headerlink" title="关于切换模式"></a>关于切换模式</h5><p>关于切换模式，切换模式有三种：0(顺序播放)、1(单曲循环)、2(随机播放) 。在点击顺序播放时会把原本的顺序列表赋给播放列表(当前播放歌曲索引要重新搜索确保，确保当前播放的歌曲是不变的)，随机播放是把当前播放列表洗牌，后续同上。</p>
<h5 id="关于主题换肤"><a href="#关于主题换肤" class="headerlink" title="关于主题换肤"></a>关于主题换肤</h5><p>关于主题换肤theme：同样是0,1,2三种 默认为0，在选择之后所有相关页面都会改变颜色(通过vuex)</p>
<h5 id="vuex-中的state"><a href="#vuex-中的state" class="headerlink" title="vuex 中的state"></a>vuex 中的state</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    <span class="attr">theme</span>: <span class="number">0</span>, <span class="comment">//主题颜色 默认值为0</span></span><br><span class="line">    <span class="attr">disc</span>: &#123;&#125;, <span class="comment">//歌单对象</span></span><br><span class="line">    <span class="attr">singer</span>: &#123;&#125;, <span class="comment">//歌手对象(和歌单对象类似)</span></span><br><span class="line">    <span class="attr">rank</span>: &#123;&#125;, <span class="comment">//榜单对象(同上)</span></span><br><span class="line">    <span class="attr">sequenceList</span>: [], <span class="comment">//顺序列表</span></span><br><span class="line">    <span class="attr">playList</span>: [], <span class="comment">//当前播放列表</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="number">0</span>, <span class="comment">//播放模式(默认0顺序播放 1单曲 2随机)</span></span><br><span class="line">    <span class="attr">playing</span>: <span class="literal">false</span>, <span class="comment">//播放状态</span></span><br><span class="line">    <span class="attr">fullScreen</span>: <span class="literal">false</span>, <span class="comment">//是否全屏</span></span><br><span class="line">    <span class="attr">currentIndex</span>: -<span class="number">1</span>, <span class="comment">//当前播放歌曲的索引,</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> state;</span><br></pre></td></tr></table></figure>



<h5 id="App根组件的模板"><a href="#App根组件的模板" class="headerlink" title="App根组件的模板"></a>App根组件的模板</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;App_Top&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Mhead</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Tab</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;AppContent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">player</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h5 id="洗牌函数"><a href="#洗牌函数" class="headerlink" title="洗牌函数"></a>洗牌函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//洗牌函数的辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomInt</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//floor为向下取整</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>) + min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//洗牌函数,打乱歌曲顺序</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _arr = arr.slice();</span><br><span class="line">    <span class="comment">//保留arr,制作一个副本</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = getRandomInt(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">let</span> temp = _arr[i];</span><br><span class="line">        _arr[i] = _arr[j];</span><br><span class="line">        _arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//截流函数 防止输入一个字符就去请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>关于Vue</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>var、let、const关键字的详细解读</title>
    <url>/2021/09/17/var%E3%80%81let%E3%80%81const%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h2><h4 id="作用：后接变量名，用来定义变量"><a href="#作用：后接变量名，用来定义变量" class="headerlink" title="作用：后接变量名，用来定义变量"></a>作用：后接变量名，用来定义变量</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num</span><br></pre></td></tr></table></figure>

<p>这里通过var关键字定义了一个num变量，我们没有给num初始化，此时num的值为undifined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str =<span class="string">&quot;kobe&quot;</span></span><br><span class="line">str=<span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>这里通过var关键字定义了一个保存“kobe”字符串值的 变量str，str的数据类型不是被规定死的，第二行的代码改变了存储值得同时改变了数据类型(改变类型是不推荐的)</p>
<h4 id="声明范围-函数作用域"><a href="#声明范围-函数作用域" class="headerlink" title="声明范围(函数作用域)"></a>声明范围(函数作用域)</h4><ul>
<li>全局作用域下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello,word&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str)</span><br><span class="line">&#125;</span><br><span class="line">test() <span class="comment">//hello ,world</span></span><br></pre></td></tr></table></figure>

<p>在全局作用域下通过var关键字定义的str变量为全局变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.num1, <span class="built_in">window</span>.num2)	<span class="comment">//1，undefined</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.num1, <span class="built_in">window</span>.num2)	<span class="comment">//1,2</span></span><br></pre></td></tr></table></figure>

<p>这里要注意使用var全局声明的变量会成为window对象的属性</p>
<ul>
<li>函数体内：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> str=<span class="string">&quot;hello, world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str)    <span class="comment">//报错！</span></span><br></pre></td></tr></table></figure>

<p>在函数体内通过var关键字定义str变量，函数被调用时会创建这个变量并给其赋值，同样在函数被执行完毕后变量被销毁。也就是说这个变量只在函数作用域内有效，在函数体外部我们是访问不到的。</p>
<ul>
<li>函数体内省略var关键字</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test()</span><br><span class="line"><span class="built_in">console</span>.log(str)  <span class="comment">//hello, world</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    str = <span class="string">&quot;hello,word&quot;</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>同样是在函数体内定义，不同的是省略了var关键字，test函数被调用时(只要被调用一次)就会创建全局变量str，该变量和在直接全局作用域下定义的一样都会成为window的属性</p>
<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><ul>
<li>例1</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str)    <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello,word&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str) 	<span class="comment">//hello, world</span></span><br></pre></td></tr></table></figure>

<p>这里不会报错是相当于执行了如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str</span><br><span class="line"><span class="built_in">console</span>.log(str)	<span class="comment">//undefined</span></span><br><span class="line">str=<span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str)	<span class="comment">//hello, world</span></span><br></pre></td></tr></table></figure>

<ul>
<li>例2</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(num)	<span class="comment">//2</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(num)	<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>相当于执行了如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num</span><br><span class="line">num=<span class="number">1</span></span><br><span class="line">num=<span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(num)	<span class="comment">//2</span></span><br><span class="line">num=<span class="number">3</span></span><br><span class="line">num=<span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(num)	<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>这就是var关键字存在的变量“提升”，也就是把所有变量声明拉倒作用域的顶部。</p>
<hr>
<h2 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h2><p>let关键字和var关键字的作用类似，不过相比于var，let显得更加的严谨，let关键字不存在“变量提升”，let关键声明的作用域范围是块作用域而var关键字是函数作用域</p>
<h4 id="作用：后接变量名，定义变量"><a href="#作用：后接变量名，定义变量" class="headerlink" title="作用：后接变量名，定义变量"></a>作用：后接变量名，定义变量</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str</span><br><span class="line">str = <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(str)	<span class="comment">//123</span></span><br><span class="line">str = <span class="string">&quot;kobe&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str)	<span class="comment">//kobe</span></span><br></pre></td></tr></table></figure>

<h4 id="声明范围-块级作用域"><a href="#声明范围-块级作用域" class="headerlink" title="声明范围(块级作用域)"></a>声明范围(块级作用域)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num)	<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(num)	<span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num)	<span class="comment">//报错！</span></span><br></pre></td></tr></table></figure>

<p>正如开头所说的let关键字不同于var关键字 他的声明范围为块级作用域，在作用域外是访问不到该变量的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> num=<span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.lgo(num)	<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.log(num)	<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> num=<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> num=<span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.log(num)	<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于let关键字在同一块级作用域中，相同标识符会报错</p>
<p>与var关键字不同 ，let关键字在全局作用域声明的变量不会成为window对象的属性</p>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>相比于var关键字，let声明的变量不会在作用域中被提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(num)	<span class="comment">//报错！ 这里不会和var一样打印undefined</span></span><br><span class="line"><span class="keyword">let</span> num=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在num被声明前执行的一瞬间成为“暂时性死区”</p>
<hr>
<h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)		<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>通过var关键字定义的迭代变量会渗透到循环体外部</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)		<span class="comment">//报错！</span></span><br></pre></td></tr></table></figure>

<p>迭代变量的作用域是循环体这个块级作用域，let关键字定义的变量范围正是块级作用域，所以外部访问会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(i)&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>加了定时器函数后打印结果变了，这是因为在退出循环时迭代变量保存的是导致循环退出的值：5，在之后的执行超时函数时所有的i都是同一个值：5</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(i)&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果0 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<p>这是因为后台会为个迭代循环声明一个新的迭代变量，他们都是互相独立的，每一个超时函数时打印的都是不同的变量实例</p>
<hr>
<h2 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h2><p>const关键字和let是类似的，唯一 一个重要区别是const关键字声明变量时必须初始化，并且在修改const定义的变量时会报错(这里指的是修改内存地址),在修改一个对象内部的一个属性时是不会报错的</p>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈JS七种数据类型</title>
    <url>/2021/09/18/%E6%B5%85%E8%B0%88JS%E4%B8%83%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="6种简单数据类型"><a href="#6种简单数据类型" class="headerlink" title="6种简单数据类型"></a>6种简单数据类型</h3><h4 id="undefined类型"><a href="#undefined类型" class="headerlink" title="undefined类型"></a>undefined类型</h4><p>undefined类型只有一个值，就是特殊值undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str</span><br><span class="line"><span class="built_in">console</span>.log(str)	<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(str===<span class="literal">undefined</span>)	<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str)		<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>当我们声明一个变量并没有对其初始化赋值时，这个变量保存的值就是undefined值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str</span><br><span class="line"><span class="built_in">console</span>.log(str)	<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(age)	<span class="comment">//报错！ 未定义</span></span><br></pre></td></tr></table></figure>

<p>注意：定义但没有初始化和本身就没有定义是不一样的</p>
<hr>
<h4 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h4><p>Null类型只有一个值，就是特殊值null</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(person)     <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<p>在定义一个保存对象的变量时可以用null值来初始化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person)		<span class="comment">//object</span></span><br></pre></td></tr></table></figure>

<p>null值表示一个空对象指针，所以在用typeof操作符时返回值为object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person				<span class="comment">//person的值为undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(person==<span class="literal">null</span>)		<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person===<span class="literal">null</span>)		<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>undefined值是由null值派生而来的，所以第二行会打印出true</p>
<hr>
<h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h4><p>布尔类型有两个字面值，true和false</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b1=<span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> b2=<span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(b1,b2)	<span class="comment">//true,false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str= <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">if</span>(str)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(str)	<span class="comment">//hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在流程控制语句中其他类型的值会被执行Boolean()转型函数来转换成布尔值，具体原则如下：</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">转换为true的值</th>
<th align="center">转换为false的值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Boolean</td>
<td align="center">true</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">非空字符串</td>
<td align="center">“    ” (空字符串)</td>
</tr>
<tr>
<td align="center">Number</td>
<td align="center">非零数值(包括无穷值)</td>
<td align="center">0、NaN</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center">任意对象</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">Undefined</td>
<td align="center">N/A (不存在)</td>
<td align="center">undefined</td>
</tr>
</tbody></table>
<hr>
<h4 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h4><p>Number类型可以用来表示整数和浮点数</p>
<ul>
<li>整数</li>
</ul>
<p>整数包括八进制，十六进制，最常用的还是十进制整数。</p>
<ul>
<li>浮点数</li>
</ul>
<p>浮点数中必须包含小数点并且小数点后面必须有数字，不然就会被转换成整数，浮点数在内存中使用的内存空间是整数的两倍。</p>
<ul>
<li>特殊值NaN</li>
</ul>
<p>NaN的意思是“不是数值”，表示本来要返回数值的但是操作失败了，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>/<span class="number">0</span>)	<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>/<span class="number">5</span>)	<span class="comment">//NaN	有关NaN的任何操作返回结果都是NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>===<span class="literal">NaN</span>)	<span class="comment">//false  NaN不等于任何值，包括他自己</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>String数据类型表示0或多个16位Unicode字符序列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1= <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> str2= <span class="string">&#x27;my&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str3=<span class="string">`friend`</span></span><br><span class="line"><span class="built_in">console</span>.log(str1,str2,str3)		<span class="comment">//hello，my,friend</span></span><br></pre></td></tr></table></figure>

<p>在定义字符串时可以使用双引号，单引号，反引号，都是合法的</p>
<ul>
<li>字符串是不可改变的</li>
</ul>
<p>字符串一旦创建，值就不能改变。如果要我们要想修改某个变量中的字符串就必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1=<span class="string">&quot;hello&quot;</span></span><br><span class="line">str1+=<span class="string">&quot;,world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1)	<span class="comment">//hello,world   原字符串“hello”会被销毁，打印的是str中保存新的字符串“hello,world”</span></span><br></pre></td></tr></table></figure>

<p>第一行str1被定义为“hello”字符串，但是在执行第二行时后台会给str1分配一个可以容纳11个字符的空间，str1由“hello”和“,world”拼接而成一个新的字符串，原本的两个字符串”hello”和”,world”会被销毁，所以说字符串是不可变的</p>
<ul>
<li>toString()方法</li>
</ul>
<p>作用：返回当前值的字符串等价物(用于数值、布尔值、对象、字符串)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name=<span class="string">&quot;kobe&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(name.toString())	<span class="comment">//字符串“kobe”</span></span><br><span class="line"><span class="keyword">let</span> flag=<span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(flag.toString())	<span class="comment">//字符串“true”</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num=<span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString())	<span class="comment">//字符串“10”</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>))	<span class="comment">//字符串“1010”</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>)))	<span class="comment">//字符串“12”	</span></span><br></pre></td></tr></table></figure>

<p>对于数值调用该方法时可以填入参数，不填参数默认返回的字符串表示的是十进制数值，填参数会反对对应进制数值的字符串表示</p>
<ul>
<li>模板字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">`first line</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	third line`</span></span><br><span class="line"><span class="built_in">console</span>.log(str)	<span class="comment">//first line</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">//	thirst line</span></span><br></pre></td></tr></table></figure>

<p>相对于单引号和双引号不同的是模板字符串是可以保留换行符和空格的</p>
<ul>
<li>向字符串中插值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;num的值为1&#x27;</span>+num)	<span class="comment">//num的值为1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age=<span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`我今年<span class="subst">$&#123;++age&#125;</span>岁`</span>)		<span class="comment">//我今年21岁</span></span><br></pre></td></tr></table></figure>

<p>也可以通过模板字符串采用上面这种写法去向字符串中插值，插入的值都会使用toString()方法转为字符串</p>
<hr>
<h4 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h4><p>symbol是ES6新增的一个原始数据类型，<a href="https://blog.csdn.net/GGGyp/article/details/102924728?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163197068816780274165248%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163197068816780274165248&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-102924728.first_rank_v2_pc_rank_v29&utm_term=symbol&spm=1018.2226.3001.4187">可以看这里</a></p>
<hr>
<h3 id="1种复杂数据类型"><a href="#1种复杂数据类型" class="headerlink" title="1种复杂数据类型"></a>1种复杂数据类型</h3><h4 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h4><p>对象是一组数据和功能的集合，Object(祖宗类)是派生其他对象的基类，Object类型的所有属性和方法在派生对象上同样存在</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure>

<p>可以通过Object类型来“new出”一个实例对象(不推荐)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person=&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">    <span class="attr">salary</span>:<span class="string">&#x27;30k&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个Person对象是一个包含了姓名，薪水，和say方法的集合</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span>, <span class="attr">salary</span>: <span class="string">&quot;30k&quot;</span>, <span class="attr">say</span>: ƒ&#125;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span></span><br><span class="line"><span class="attr">salary</span>: <span class="string">&quot;30k&quot;</span></span><br><span class="line"><span class="attr">say</span>: ƒ say()</span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"><span class="attr">constructor</span>: ƒ <span class="built_in">Object</span>()</span><br><span class="line"><span class="attr">hasOwnProperty</span>: ƒ hasOwnProperty()</span><br><span class="line"><span class="attr">isPrototypeOf</span>: ƒ isPrototypeOf()</span><br><span class="line"><span class="attr">propertyIsEnumerable</span>: ƒ propertyIsEnumerable()</span><br><span class="line"><span class="attr">toLocaleString</span>: ƒ toLocaleString()</span><br><span class="line"><span class="attr">toString</span>: ƒ toString()</span><br><span class="line"><span class="attr">valueOf</span>: ƒ valueOf()</span><br><span class="line"><span class="attr">__defineGetter__</span>: ƒ __defineGetter__()</span><br><span class="line"><span class="attr">__defineSetter__</span>: ƒ __defineSetter__()</span><br><span class="line"><span class="attr">__lookupGetter__</span>: ƒ __lookupGetter__()</span><br><span class="line"><span class="attr">__lookupSetter__</span>: ƒ __lookupSetter__()</span><br><span class="line">get __proto__: ƒ __proto__()</span><br><span class="line">set __proto__: ƒ __proto__()</span><br></pre></td></tr></table></figure>

<p>每个对象实例都会有来自Object的方法和属性(通过原型链)</p>
<ul>
<li>constructor属性</li>
</ul>
<p>属性值为Object()函数，用于创建当前对象的函数</p>
<ul>
<li>hasOwnProperty(peropertyname)</li>
</ul>
<p>用于判断当前对象本身是否具有该属性(不会通过原型链去查找),属性名是字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>))		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>isPrototypeOf(object)</li>
</ul>
<p>用于判断当前对象是否在参数对象的原型链上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">person.__proto__ = p</span><br><span class="line"><span class="built_in">console</span>.log(p.isPrototypeOf(person))	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>propertyIsEnumerable(propertyName)</li>
</ul>
<p>用于判断给定属性是否可以通过for-in来枚举 ，参数同样是字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = &#123;</span><br><span class="line">    arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line">console.log(num.propertyIsEnumerable(<span class="string">&#x27;arr&#x27;</span>))	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>toLocaleString( )</li>
</ul>
<p>返回对象的字符串表示，该字符串反映对象所在的本地化执行环境</p>
<ul>
<li>toString( )</li>
</ul>
<p>返回对象的字符串表示</p>
<ul>
<li>valueOf( )</li>
</ul>
<p>返回对象对应的字符串、数值或布尔值表示</p>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的全等和不全等、等于和不等于</title>
    <url>/2021/09/21/JS%E4%B8%AD%E7%9A%84%E5%85%A8%E7%AD%89%E5%92%8C%E4%B8%8D%E5%85%A8%E7%AD%89%E3%80%81%E7%AD%89%E4%BA%8E%E5%92%8C%E4%B8%8D%E7%AD%89%E4%BA%8E/</url>
    <content><![CDATA[<h2 id="全等和不全等"><a href="#全等和不全等" class="headerlink" title="全等和不全等"></a>全等和不全等</h2><p>全等和不全等比较的是符号两侧的操作数，以全等操作符为例，如果操作数满足全等则返回true，否则返回false。</p>
<h4 id="全等"><a href="#全等" class="headerlink" title="全等"></a>全等</h4><p>符号：===</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1=<span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="keyword">let</span> str2=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(str1===str2)		<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="不全等"><a href="#不全等" class="headerlink" title="不全等"></a>不全等</h4><p>符号：！==</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1=<span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="keyword">let</span> str2=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(str1!==str2)		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="相等和不相等"><a href="#相等和不相等" class="headerlink" title="相等和不相等"></a>相等和不相等</h2><p>相等和不相等操作符也同样是比较两个操作数，以相等操作符为例，如果两个操作数满足相等则返回true，否则返回false。不过与全等和不全等操作符的区别在于：相等和不相等操作符会先对操作数进行强制类型转换，转后的操作数再进行比较。</p>
<h4 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h4><p>符号：==</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1=<span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="keyword">let</span> str2=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(str1==str2)		<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(str1===str2)	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flag=<span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> num=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(flag==num)		<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(flag===num)		<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="不相等"><a href="#不相等" class="headerlink" title="不相等"></a>不相等</h4><p>符号：! =</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1=<span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="keyword">let</span> str2=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> str3=<span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1!=str2)		<span class="comment">//false   先是类型转换，之后进行比较</span></span><br><span class="line"><span class="built_in">console</span>.log(str1!==str2)	 <span class="comment">//true	  对于全等操作福这两个操作数不进行强制类型转换，自然就不全等	</span></span><br><span class="line"><span class="built_in">console</span>.log(str2!=str3)		<span class="comment">//true	  </span></span><br><span class="line"><span class="built_in">console</span>.log(str2!==str3)	  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h5 id="对于相等和不相等操作符对操作数进行强制类型转换的规则如下："><a href="#对于相等和不相等操作符对操作数进行强制类型转换的规则如下：" class="headerlink" title="对于相等和不相等操作符对操作数进行强制类型转换的规则如下："></a>对于相等和不相等操作符对操作数进行强制类型转换的规则如下：</h5><ul>
<li><p>布尔值会直接转换成数值进行比较：false：0；true：1</p>
</li>
<li><p>字符串遇到数值则会转换为数值再进行比较</p>
</li>
<li><p>对于对象，如果两个操作数都是对象则比较二者是否为同一个对象，如果两个操作数指向同一个对象则返回true，否则返回false。如果其中的一个操作数为对象则会调用valueOf方法取到原始值，之后再进行比较(按照上述规则)</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">&#x27;zhangsan&#x27;</span>)	<span class="comment">//相当于const p=new String(&#x27;zhangsan&#x27;)</span></span><br><span class="line"><span class="built_in">console</span>.log(p.valueOf() == <span class="string">&#x27;zhangsan&#x27;</span>)	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(p == <span class="string">&#x27;zhangsan&#x27;</span>)	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1=&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span>   p2=p1</span><br><span class="line"><span class="built_in">console</span>.log(p1==p2)		<span class="comment">//true</span></span><br><span class="line">p2=&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p1==p2)		<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于null和undefined，null和undefined是相等的，但是无论和谁比较，他们都不会被强转。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>==<span class="literal">undefined</span>)		<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>===<span class="literal">undefined</span>)		<span class="comment">//false		对于全等返回结果依然是false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于NaN，NaN不等于任何值包括他自己。涉及到操作符是NaN的比较，只要是相等操作符则返回false，不相等则返回true</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>==<span class="literal">NaN</span>)	<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>!=<span class="string">&#x27;&#x27;</span>)	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>!=<span class="number">1</span>)	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>!=&#123;&#125;)	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的垃圾回收机制</title>
    <url>/2021/09/22/JS%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>JavaScript是一门使用垃圾回收的语言，也就是执行环境负责在代码执行时管理内存。JS不同于其他的编程语言，比如在C，C++中每当我们为变量在堆内存中开辟一块空间后往往需要开发者去手动的回收掉变量，而<strong>在JS中是通过自动内存管理实现内存分配和闲置资源回收</strong>，这不在需要开发者去“亲力亲为”的释放申请的内存空间。</p>
<h4 id="垃圾回收原理"><a href="#垃圾回收原理" class="headerlink" title="垃圾回收原理"></a>垃圾回收原理</h4><p style="color: red">垃圾回收程序会每隔一段时间(呈周期性)去确定哪个变量不会使用，然后释放掉它所占的内存。</p>



<p>在变量的生命周期结束时，会被释放内存。看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num2=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>在函数test被调用时会创建对应的上下文环境，同时会在栈内存分配空间来保存声明的num2变量。在函数执行完毕后，此时局部变量num2就变成了“不再需要的变量”，所以垃圾回收程序会在栈内存中释放该变量所占的空间。</p>
<p>在上述代码中全局变量num1暂时是不会被释放内存的，我们不知道哪个函数还会使用到该变量，全局变量会在页面关闭时才会成为“不在使用的变量”。</p>
<p>以上代码片段是最理想的状态，实际上并不会那样明显，看如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj1=&#123;<span class="attr">name</span>:<span class="string">&#x27;kobe&#x27;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj2=&#123;<span class="attr">name</span>:<span class="string">&#x27;kobe&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> obj2</span><br><span class="line">&#125;</span><br><span class="line">test1()</span><br><span class="line"><span class="keyword">let</span> o=test2()</span><br></pre></td></tr></table></figure>

<p>在test1函数执行完毕后内部在堆内存上申请的空间会被释放掉(和第一个代码片段情况相同)，但是当代码执行流进入test2函数上下文后，直到调用结束也并不会释放掉在堆内存上申请的空间，这是因为全局变量o指向了函数返回的obj2。</p>
<p>基于两个代码片段，我们可以确定垃圾回收程序一定跟踪记录了哪个变量会被使用，哪个变量不再被使用，最后将不再被使用的变量释放内存。至于如何标记变量有两种主要的标记策略：<strong>标记清理和引用计数</strong>。</p>
<hr>
<p><em>以下关于两种标记策略的内容全部来自《JavaScript高级程序设计第四版》</em></p>
<h4 id="标记清理-最常用"><a href="#标记清理-最常用" class="headerlink" title="标记清理(最常用)"></a>标记清理(最常用)</h4><p>JavaScript最常用的垃圾回收策略是**标记清理(mark-and-sweep)**。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。</p>
<p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护”在上下文中”和”不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。</p>
<p>垃圾回收程序运行的时候，会标记内存中储存的所有变量(记住，标记方法有很多种)。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次<strong>内存清理</strong>，销毁带标记的所有值并收回它们的内存。</p>
<blockquote>
<p>——《JavaScript高级程序设计第四版》</p>
</blockquote>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>另一种没那么常用的垃圾回收策略是<strong>引用计数</strong> 。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用地变量被其他值给覆盖了，那么引用数减1。当一个值地引用数为0时，就说明没办法再访问到这个值了，因此可以安全地回收其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。</p>
<p>引用计数最早由Netscape Navigator 3.0采用，但很快就遇到了严重的问题：循环引用。所谓<strong>循环引用</strong>，就是对象A有一个指针指向对象B，而对象B也引用了对象A。比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> objectA=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	<span class="keyword">let</span> objectB=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	objectA.someOtherObject=objectB;</span><br><span class="line">	objectB.anotherObject=objectA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，objectA和objectB通过各自的属性相互引用，意味着它们的引用数都是2。在标记清理策略下，这不是问题，因为在函数结束后，这两个对象都不在作用域中。而在引用计数策略下，objectA和objectB在函数结束后还会存在，因为它们的引用数永远不会变成0。如果函数被多次调用，则会导致大量的内存永远不会被释放。为此，Netscape在4.0版放弃了引用计数，转而采用标记清理，事实上，引用计数策略的问题还远不止如此。</p>
<p>在IE8以及更早版本的IE中，并非所有对象都是原生JavaScript对象。BOM和DOM中的对象是C++实现的组件对象模型(COM，Component Object Model)对象，而COM对象使用引用计数实现垃圾回收。因此，即使这些版本IE的JavaScript引擎使用标记清理，JavaScript存取的COM对象依旧使用引用计数。换句话说，只要涉及COM对象，就无法避免循环引用问题。下面这个简单的例子就展示了涉及COM对象的循环引用问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element=<span class="built_in">document</span>.getElementById(<span class="string">&quot;some_element&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> myObject=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObject.element=element;</span><br><span class="line">element.someObject=myObject;</span><br></pre></td></tr></table></figure>

<p>这个例子在一个DOM对象（element）和一个原生JavaScript对象（myObject）之间制造了循环引用。myObject变量有一个名为element的属性指向DOM对象element，而element对象有一个someObject属指回myObject对象。由于存在循环引用，因此DOM元素的内存永远不会被回收，即使它一家被从页面上删除了也是如此。</p>
<p>为避免类似的循环引用问题，应该在确保不使用的情况下切断原生JavaScript对象与DOM元素之间的连接。比如，通过以下代码可以清除前面例子中建立的循环引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myObject.element=<span class="literal">null</span>;</span><br><span class="line">element.someObject=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>把变量设置为null实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收。</p>
<p>为了补救这一点，IE9把BOM和DOM对象都改成了JavaScript对象，这同时也避免了由于存在两套垃圾回收算法而导致的问题，还消除了常用的内存泄露现象。</p>
<blockquote>
<p>——《JavaScript高级程序设计第四版》</p>
</blockquote>
<hr>
<h4 id="什么条件下会进行垃圾回收"><a href="#什么条件下会进行垃圾回收" class="headerlink" title="什么条件下会进行垃圾回收"></a>什么条件下会进行垃圾回收</h4><p>垃圾回收程序呈周期性运行，如果内存中分配了很多变量则可能造成性能损失。IE6的垃圾回收程序是根据内存的分配数来运行的：比如分配了256个变量，4096个对象/数组字面量和数组槽位(slot)，64kb字符串。只要满足以上任意条件，垃圾回收程序就会运行。我们可以假设一下这种情况：在整个程序内我们创建了许多变量，在这整个程序运行过程中有超过256个变量是被使用的。这样就会造成一种现象，垃圾回收程序会不停的运行。</p>
<p>所以在IE7发布后，相比原先规定死的条件，js引擎将动态改变变量、字面量或数组槽位等作为触发垃圾回收程序的阈值。IE7的起始阈值和IE6的相同，但是如果垃圾回收程序回收的内存不到已分配内存的15%，这说明有内存中好多内容是不需要回收的，此时触发垃圾回收程序的阈值会翻一倍，这样的目的是为了让垃圾回收程序触发的不会那么敏感。如果有一次回收的内存达到了 分配内存的85%，阈值重置为默认值(这样会把需要清理的部分全部清理)。这样会大大提高性能。</p>
<p>总结起来就一句话：IE7中垃圾回收程序回收内存的多少与分配的内存会进行比较，如果特别少(不到分配内存的15%)，就会提高触发垃圾回收程序的条件，减少频繁回收。反之如果回收的内存占比达到了85%就恢复触发条件。这个触发条件是动态的，根据回收内存与分配内存的比值。</p>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>变量提升练习题</title>
    <url>/2021/09/24/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<p>例:：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)	</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    a = <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>



<p>打印结果：</p>
<p><img src="/2021/09/24/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%BB%83%E4%B9%A0%E9%A2%98/1.jpg" alt="1"></p>
<p>分析：</p>
<p>首先，全局变量a会提升,对于1,2行相当执行了如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//这里的a相当于只声明但未赋值    undefined</span></span><br><span class="line">a=<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>代码执行流进入test函数，函数体内并没有声明a变量，在函数上下文中是找不到a变量的(所有定义的变量都会在上下文关联的变量对象上)，所以通过作用域链向全局变量对象上查找变量a，此时变量a的值是12.所以第五行打印的结果是12</p>
<p>在函数内部打印了全局变量a后 ，又对全局变量a进行了修改，值为13。所以在函数执行完毕后，全局变量a的值为13，所以最后一行打印结果 为13。</p>
<p>变：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)	</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>

<p>这里是对第一个例子做了一个变形，仅仅把函数体内部 a=13 前面加了个var关键字，下面看打印结果：</p>
<p><img src="/2021/09/24/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%BB%83%E4%B9%A0%E9%A2%98/2.png" alt="2"></p>
<p>这也很好理解，区别就在于函数体内部的a变量不再是全局变量：代码执行流进入函数后，会搜索自身上下文中的变量(所有定义的变量都会在上下文关联的变量对象上)，此时a变量并未赋值，是undefined，所以打印结果为undefined。注意，这里的a变量为函数的局部变量，我们并没有像之前那样去顺着作用域链去全局上下文中找数据。</p>
<p>最后一行打印的结果为12，因为全局变量a在第一次赋值为12后 并没有被改变。</p>
<p><strong>看到这里可以给弟弟来个三联吗？</strong></p>
<p><img src="/2021/09/24/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%BB%83%E4%B9%A0%E9%A2%98/3.jpg"></p>
<p>练一练：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="/2021/09/24/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%BB%83%E4%B9%A0%E9%A2%98/4.png" alt="4"></p>
<p>分析：</p>
<p>代码执行流进入函数，会在函数上下文中找a变量，此时a变量是没有赋值的，值是undefined。所以呀，if判断条件返回结果为true，代码继续执行。a被赋值10，打印a变量自然结果为10。</p>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈JS中的执行上下文和作用域链(基础)</title>
    <url>/2021/09/21/%E6%B5%85%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(%E5%9F%BA%E7%A1%80)/</url>
    <content><![CDATA[<p><strong><a href="https://mr-programming.github.io/2021/09/26/%E6%B5%85%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(%E8%BF%9B%E9%98%B6)%EF%BC%88%E5%8C%85%E5%90%AB%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%89/">点这里，关于变量提升的原理和上下文的创建，递归函数上下文栈具体内容请看进阶篇</a></strong></p>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><ul>
<li><p>对于执行上下文(简称“上下文”)，我们可以将其理解成变量或函数的代码运行环境，在JS中的执行上下文一共有三种：全局上下文、函数上下文、eval。</p>
</li>
<li><p>每一个上下文环境都会有它关联的变量对象，这个变量对象保存了这个上下文环境中的所有的数据，包括：变量和函数。</p>
</li>
</ul>
<h4 id="全局上下文与函数上下文"><a href="#全局上下文与函数上下文" class="headerlink" title="全局上下文与函数上下文"></a>全局上下文与函数上下文</h4><ul>
<li><p>在最外层的上下文就是全局上下文，函数上下文可以通过作用域链去访问保存在全局上下文中的数据。</p>
</li>
<li><p>所有上下文会在其所有代码执行完毕后销毁，全局上下文会在关闭网页时销毁</p>
</li>
<li><p>全局上下文是唯一的，程序运行立马创建。函数上下文在函数被调用时创建，可以有多个</p>
</li>
</ul>
<p>所有上下文中，最外层的上下文为全局上下文，也就是window对象。通过var定义的全局变量和函数都保存在了window对象身上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;kobe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   	<span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.hasOwnProperty(<span class="string">&#x27;getName&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.getName)</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="/2021/09/21/%E6%B5%85%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(%E5%9F%BA%E7%A1%80)/1.png" alt="1"></p>
<p>大家有没有注意到上面说的是用var定义全局变量会保存到全局上下文window对象，并没有说用let、const定义。先看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> num2=<span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.hasOwnProperty(<span class="string">&#x27;num1&#x27;</span>))	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.hasOwnProperty(<span class="string">&#x27;num2&#x27;</span>))	<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNum1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(num1)	<span class="comment">//拿到全局变量num1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNum2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(num2)	<span class="comment">//拿到全局变量num2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getNum1()	<span class="comment">//1</span></span><br><span class="line">getNum2()	<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>很明显，使用let 和const定义的变量并不会保存到全局上下文当中。但是在函数体内部(函数上下文)同样可以通过作用域链(下面会介绍)正常访问的。</p>
<h4 id="上下文栈"><a href="#上下文栈" class="headerlink" title="上下文栈"></a>上下文栈</h4><p>在一个JS程序运行时必然会有多个上下文，那么就会有执行上下文的栈。那么一个程序首次运行时，首先压入栈中的就是全局上下文，随着代码的执行，其他的函数上下文会不断地入栈，出栈。如下图：</p>
<p><img src="/2021/09/21/%E6%B5%85%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(%E5%9F%BA%E7%A1%80)/2.png" alt="2"></p>
<p><img src="/2021/09/21/%E6%B5%85%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(%E5%9F%BA%E7%A1%80)/3.png" alt="3"></p>
<p>整个过程中 一旦函数被调用则会创建对应的函数上下文放并将其压出栈顶，随着代码运行完毕函数上下文会被弹出上下文栈并销毁。此时上下文栈的控制权会被返还给之前的上下文(可能是函数上下文也可能是全局上下文)。不难发现全局上下文压入栈底后始终没有出栈，所有的函数上下文不断地进出栈，最后当程序结束(关闭网页)时全局上下文会出栈销毁。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>代码执行流每进入一个新的上下文，都会创建一个作用域链，用于搜索变量和函数。这个作用域链的范围或大或小，位于作用域链顶端的是代码正在执行的上下文的变量对象。代码在执行时的标识符解析是通过沿作用域链逐级搜索标识符完成的，说起来可能有点绕。看示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b=<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在该函数内通过作用域链完成a和b值的交换</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> c=b</span><br><span class="line">        <span class="comment">//访问函数体外部的变量</span></span><br><span class="line">        b=a</span><br><span class="line">        a=c</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用test1函数</span></span><br><span class="line">    test1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行函数</span></span><br><span class="line">test2()</span><br></pre></td></tr></table></figure>

<p>上述代码涉及到三个上下文：全局上下文、两个局部的函数上下文。</p>
<p>全局上下文中包含a变量、test2函数；</p>
<p>test2函数上下文包含b变量、test1函数。可以访问父级上下文window对象身上的全局变量a；</p>
<p>test1函数上下文包含c变量，它可以访问父上下文test2中的b变量和window对象中的a变量。</p>
<p>看图说话：</p>
<p><img src="/2021/09/21/%E6%B5%85%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(%E5%9F%BA%E7%A1%80)/4.png" alt="4"></p>
<p>每一个矩形表示不同的上下文，内部的子级上下文可以访问外部的父级上下文中的任何数据，而反之外部的父级上下文不可以访问内部的子级上下文。他们之间的连接是线性的、有序的。test1函数上下文的作用域链包含了三个变量对象，分别是test1的变量对象、test2的变量对象和window对象。同理test2函数上下文的作用域链包含了两个变量对象，分别是test2的变量对象和window对象。每一个上下文都会从自身的变量对象上搜索数据(代码运行时，自身的变量对象处于作用域链的顶端)，搜索不到则会到上一级的变量对象中去搜索，以此类推。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>执行上下文分为全局上下文、函数上下文、块级上下文。</li>
<li>代码执行流没进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。</li>
<li>函数上下文既可以访问它本身的变量，也可以访问包含它的上下文和全局上下文中的变量</li>
<li>全局上下文只可以访问自身的变量和函数</li>
</ul>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中字符串常用的几个方法</title>
    <url>/2021/09/28/JS%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>字符串原始值本身是没有属性和方法的，在调用相关属性和方法时后台会创建对应的原始包装类型对象，进而暴露出属性和方法</strong></p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length)		<span class="comment">//11</span></span><br></pre></td></tr></table></figure>

<p>在第二行打印语句相当于执行了如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello,world&quot;</span>)	<span class="comment">//临时创建一个String实例</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length)		<span class="comment">//11</span></span><br></pre></td></tr></table></figure>

<p>在执行打印语句后创建的String实例对象会被销毁</p>
<hr>
<h4 id="书归正传"><a href="#书归正传" class="headerlink" title="书归正传"></a>书归正传</h4><h5 id="从超类继承的三个方法：valueOf-、toLocaleString-、toString-。他们返回原始值字符串"><a href="#从超类继承的三个方法：valueOf-、toLocaleString-、toString-。他们返回原始值字符串" class="headerlink" title="从超类继承的三个方法：valueOf()、toLocaleString()、toString()。他们返回原始值字符串"></a><strong>从超类继承的三个方法：valueOf()、toLocaleString()、toString()。他们返回原始值字符串</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.valueOf())		<span class="comment">//hello</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toLocaleString())		<span class="comment">//hello</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toString())		<span class="comment">//hello</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="charAt-index-返回指定索引位置的字符"><a href="#charAt-index-返回指定索引位置的字符" class="headerlink" title="charAt(index)   返回指定索引位置的字符"></a>charAt(index)   返回指定索引位置的字符</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charAt(<span class="number">4</span>))		<span class="comment">//o</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charAt(<span class="number">5</span>))		<span class="comment">//,</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="concat-value1-value2…-拼接字符串，可接受多个参数，将其拼接并返回-原字符串不变"><a href="#concat-value1-value2…-拼接字符串，可接受多个参数，将其拼接并返回-原字符串不变" class="headerlink" title="concat(value1,value2…)  拼接字符串，可接受多个参数，将其拼接并返回(原字符串不变)"></a>concat(value1,value2…)  拼接字符串，可接受多个参数，将其拼接并返回(原字符串不变)</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1=<span class="string">&quot;kobe&quot;</span></span><br><span class="line"><span class="keyword">const</span> str2=<span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> s=str2.concat(<span class="string">&quot;--&quot;</span>,str1)</span><br><span class="line"><span class="built_in">console</span>.log(s)		<span class="comment">//hello--kobe</span></span><br></pre></td></tr></table></figure>

<p> 这个方法和用+拼接字符串效果是一样的</p>
<hr>
<h5 id="三个从字符串中提取子字符串的方法-返回截取字符串，不改变原字符串-slice、substring、substr"><a href="#三个从字符串中提取子字符串的方法-返回截取字符串，不改变原字符串-slice、substring、substr" class="headerlink" title="三个从字符串中提取子字符串的方法(返回截取字符串，不改变原字符串) : slice、substring、substr"></a><strong>三个从字符串中提取子字符串的方法(返回截取字符串，不改变原字符串) : slice、substring、substr</strong></h5><ul>
<li>slice(value1，value2)  和 substring(value1,value2) 方法类似   ：</li>
</ul>
<p><strong>参数为正数时</strong></p>
<p> 两个方法都是返回索引从value1到value2的子字符串，区间 [value1,value2) 不包括索引值为value2的字符，如果省略第二个参数，那么表示从索引值value1一直截取到最后并返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1=<span class="string">&quot;hello,world&quot;</span>	</span><br><span class="line"><span class="built_in">console</span>.log(str1.slice(<span class="number">2</span>,<span class="number">4</span>))	<span class="comment">//ll(注意，是闭开区间)</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.slice(<span class="number">2</span>))		<span class="comment">//llo,world</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.substring(<span class="number">2</span>,<span class="number">4</span>))	<span class="comment">//ll(注意，是闭开区间)</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.substring(<span class="number">2</span>))		<span class="comment">//llo,world</span></span><br></pre></td></tr></table></figure>

<p><strong>当参数为负数时</strong></p>
<p> slice方法将所有负数参数转换为字符串长度加该负数参数处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str1.slice(-<span class="number">3</span>))		<span class="comment">//rld 从索引为8的位置截取到末尾</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.slice(-<span class="number">3</span>,-<span class="number">1</span>))		<span class="comment">//rl   [8,10)</span></span><br></pre></td></tr></table></figure>

<p> substring方法将所有负数参数转换为0处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str1.substring(-<span class="number">3</span>))		<span class="comment">//hello,world</span></span><br></pre></td></tr></table></figure>

<ul>
<li>substr(value1,value2) 该方法第一个参数为截取开始的索引，第二个参数为截取的个数，省略则截取到末尾</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1=<span class="string">&quot;hello,world&quot;</span>	</span><br><span class="line"><span class="built_in">console</span>.log(str1.substr(<span class="number">2</span>,<span class="number">4</span>))	<span class="comment">//llo,</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.substr(<span class="number">2</span>))		<span class="comment">//llo,world</span></span><br></pre></td></tr></table></figure>

<p>对于参数是负值的情况，substr会将第一个负值参数转换为数组长度加该负数，第二个负值参数转换为0</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str1.substr(-<span class="number">3</span>))		<span class="comment">//rld</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.substr(<span class="number">3</span>,-<span class="number">4</span>))		<span class="comment">//&quot;&quot;（空）</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="搜索子字符串位置的方法-：indexOf-、lastIndexOf"><a href="#搜索子字符串位置的方法-：indexOf-、lastIndexOf" class="headerlink" title="搜索子字符串位置的方法 ：indexOf()、lastIndexOf()"></a>搜索子字符串位置的方法 ：indexOf()、lastIndexOf()</h5><p>这两个方法都是从指定字符串中搜索参数字符串的位置，第一个参数为参数字符串，第二个参数是起始位置，可以省略。二者区别就是： indexOf是从前往后搜索，lastIndexOf是从后往前搜索。找不到则返回-1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1=<span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.indexOf(<span class="string">&quot;lo&quot;</span>))		<span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.lastIndexOf(<span class="string">&quot;lo&quot;</span>))		<span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.indexOf(<span class="string">&quot;le&quot;</span>))		<span class="comment">//-1</span></span><br></pre></td></tr></table></figure>

<h5 id="判断是否包含另一个字符串的方法：includes"><a href="#判断是否包含另一个字符串的方法：includes" class="headerlink" title="判断是否包含另一个字符串的方法：includes()"></a>判断是否包含另一个字符串的方法：includes()</h5><p>参数是用于搜索的字符串,可以加第二个参数，表示开始搜索位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1=<span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.includes(<span class="string">&quot;wor&quot;</span>))		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h5><p>该方法会创建字符串的一个副本，去掉前后空格并放回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1=<span class="string">&quot; hello,world      &quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.trim())	<span class="comment">//hello,world</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.trim().length)		<span class="comment">//11</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h5><p>该方法参数为一个整数，将字符串复制指定次数并拼接成一个副本返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1=<span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.repeat(<span class="number">3</span>))		<span class="comment">//hellohellohello</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="转化成数组的一个方法：split"><a href="#转化成数组的一个方法：split" class="headerlink" title="转化成数组的一个方法：split()"></a>转化成数组的一个方法：split()</h5><p>该方法接收两个参数，第一个参数为字符串或正则表达式，第二个参数为数组长度(可选)  该方法返回一个数组：该数组是由第一个参数分割后的子字符串组成的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str=<span class="string">&quot;h,e,l,l,o,w,o,r,l,d&quot;</span></span><br><span class="line"><span class="keyword">let</span> str1=str.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str1)		<span class="comment">//Array(10) [h,e,l,l,o,w,o,r,l,d]</span></span><br></pre></td></tr></table></figure>

<p>字符串还有其他的方法，这里只是一部分常用的，今天就先写到这。</p>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈JS中的执行上下文和作用域链(进阶)（包含变量提升、VO、AO等）</title>
    <url>/2021/09/26/%E6%B5%85%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(%E8%BF%9B%E9%98%B6)%EF%BC%88%E5%8C%85%E5%90%AB%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%81VO%E3%80%81AO%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<p><strong><a href="https://mr-programming.github.io/2021/09/21/%E6%B5%85%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(%E5%9F%BA%E7%A1%80)/">点这里，关于关上下文和作用域链内容请看基础篇</a></strong></p>
<p>先看两段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b=<span class="string">&quot;变量b的值&quot;</span></span><br><span class="line">    <span class="keyword">var</span> a</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">    a=<span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//a()</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    a=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line">test1()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i  == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test2(i+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">test2(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<p>先思考一下控制台的打印结果：………</p>
<img src="/2021/09/26/%E6%B5%85%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(%E8%BF%9B%E9%98%B6)%EF%BC%88%E5%8C%85%E5%90%AB%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%81VO%E3%80%81AO%E7%AD%89%EF%BC%89/2.jpg" alt="2" style="zoom: 67%;">

<center style="color: red">下面是控制台的输出(分两次打印)</center>

<center style="color: blue">代码片段一(test1)打印结果</center>

<p><img src="/2021/09/26/%E6%B5%85%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(%E8%BF%9B%E9%98%B6)%EF%BC%88%E5%8C%85%E5%90%AB%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%81VO%E3%80%81AO%E7%AD%89%EF%BC%89/1.png" alt="1"></p>
<center style="color: blue">代码片段二(test2)打印结果</center>

<p><img src="/2021/09/26/%E6%B5%85%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(%E8%BF%9B%E9%98%B6)%EF%BC%88%E5%8C%85%E5%90%AB%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%81VO%E3%80%81AO%E7%AD%89%EF%BC%89/3.png" alt="3"></p>
<p>———–(下面会有详细解析过程)</p>
<p><em>如果这个结果不在你的意料之中，那么恭喜你，这篇文章很适合你。当然，如果有大佬看到有理解偏差的地方也可以指正。</em></p>
<p>如果不知道什么是上下文、作用域链、上下文栈的话可以去看上一篇，连接在顶部。</p>
<hr>
<p><strong>要向弄清原因，我们首先要知道函数上下文创建前后的具体过程</strong></p>
<p>当代码执行流进入对应的代码片段，但在代码执行前，会有个预加载的过程，这个时候会创建对应的上下文环境（这里想表达的意思就是上下文创建过程是在代码执行前完成的）。</p>
<h4 id="创建阶段："><a href="#创建阶段：" class="headerlink" title="创建阶段："></a>创建阶段：</h4><p>创建上下文一共分为(包含)三部分：</p>
<ul>
<li><p><strong>创建变量对象(VO)(按照下面顺序创建变量对象；注意：变量对象（VO）是JS引擎上实现的，并不能在JS环境中直接访问)</strong>**</p>
<ol>
<li>创建arguments伪数组对象，搜索实参并赋值(函数上下文中的变量对象会创建arguments，在全局上下文中是没有arguments的)</li>
<li>扫描函数声明：扫描代码中的函数(用function定义)，将对应的函数名作为VO的一个属性，该属性保存了一个指针，该指针指向函数在内存中的位置。扫描时如果有同名的属性，则对应的属性值会被覆盖(覆盖掉原有的)。</li>
<li>扫描变量声明(var)：扫描代码中的变量，会将变量名作为VO对象的一个属性，不过不同的是属性值会被初始化为undefined。扫描时如果有同名的属性则会直接跳过(不会覆盖了)。</li>
</ol>
</li>
<li><p><strong>创建作用域链</strong></p>
<p>作用域链里面每一级上下文的变量对象，最顶端是正在执行上下文的变量对象，往下依次是上一级上下文的变量对象。</p>
</li>
<li><p><strong>确定上下文中this指向</strong></p>
<p>全局上下文中 this指向window对象</p>
<p>函数上下文中 this指向取决于函数调用方式</p>
</li>
</ul>
<h4 id="执行阶段："><a href="#执行阶段：" class="headerlink" title="执行阶段："></a>执行阶段：</h4><p>此时会为VO变量对象被激活成了<strong>AO活动对象</strong>，我们所访问的数据都是AO对象上的，随着代码的执行，不断有变量被赋值(原本的变量保存的值是undefined，会随着代码执行被赋予新值)。</p>
<h4 id="执行阶段结束，出栈等待回收"><a href="#执行阶段结束，出栈等待回收" class="headerlink" title="执行阶段结束，出栈等待回收"></a>执行阶段结束，出栈等待回收</h4><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)		<span class="comment">//f a()</span></span><br><span class="line">    <span class="built_in">console</span>.log(b)		<span class="comment">//6</span></span><br><span class="line">    <span class="built_in">console</span>.log(num)	<span class="comment">//undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(fn)		<span class="comment">//undefined</span></span><br><span class="line">	<span class="keyword">var</span> a=<span class="number">1</span>				</span><br><span class="line">    <span class="built_in">console</span>.log(a)		<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fn=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(num)	<span class="comment">//2</span></span><br><span class="line">    <span class="built_in">console</span>.log(fn)		<span class="comment">//f ()&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>创建全局上下文(伪代码)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ExecutionContext=&#123;</span><br><span class="line">    <span class="attr">VO</span>:&#123;...&#125;,</span><br><span class="line">    <span class="attr">scopeChain</span>:&#123;...&#125;,</span><br><span class="line">    <span class="attr">this</span>:<span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码执行流进入first，创建函数上下文(伪代码)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">firstExecutionContext=&#123;</span><br><span class="line">    <span class="comment">//变量对象</span></span><br><span class="line">    <span class="attr">VO</span>:&#123;</span><br><span class="line">        <span class="attr">arguments</span>:&#123;</span><br><span class="line">            <span class="number">0</span>:f a()，	<span class="comment">//注意：属性名相同时，函数会覆盖掉原有的属性；原本的形参变量为a和函数名相同</span></span><br><span class="line">            <span class="number">1</span>:<span class="number">6</span>，</span><br><span class="line">            <span class="attr">length</span>:<span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">a</span>:f a(),		</span><br><span class="line">        <span class="attr">b</span>:<span class="number">6</span>		<span class="comment">//原本的形参</span></span><br><span class="line">        <span class="attr">num</span>:<span class="literal">undefined</span>,</span><br><span class="line">    	<span class="attr">fn</span>:<span class="literal">undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">scopeChain</span>:&#123;VO(first),<span class="built_in">window</span>&#125;,</span><br><span class="line">    <span class="attr">this</span>:<span class="built_in">window</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着代码执行，第6行a被赋值1，第7行打印出1，第八行num原本的值为undefined，被赋值为2，同理代码执行到第12行，fn被赋值一个匿名函数。</p>
<hr>
<p>如果上述内容你看懂了的话(如果没看懂那一定是我没讲清楚hhh)，对于第一个代码片段应该就有了思路了，其实很简单的。下面先回顾一下第一个代码片段</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b=<span class="string">&quot;变量b的值&quot;</span></span><br><span class="line">    <span class="keyword">var</span> a</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">    a=<span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//a()</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    a=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line">test1()</span><br></pre></td></tr></table></figure>

<h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>代码执行流进入test1函数，创建对应上下文环境：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">firstExecutionContext:&#123;</span><br><span class="line">	<span class="attr">VO</span>:&#123;</span><br><span class="line">        <span class="attr">arguments</span>:&#123;...&#125;</span><br><span class="line">        <span class="attr">a</span>:pointer to <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">...<span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>)...</span>)		//注意函数申明优先于变量申明</span></span><br><span class="line"><span class="function">        <span class="title">b</span>:<span class="title">undifined</span></span></span><br><span class="line"><span class="function">    &#125;，</span></span><br><span class="line"><span class="function">    <span class="title">scopeChain</span>:</span>&#123;...&#125;,</span><br><span class="line">    <span class="attr">this</span>:&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="comment">//ƒ a() &#123;</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>打印的a为保存在变量对象中的属性a，这个a保存了函数在内存中的位置，所以打印出a函数(函数体内部有 console.log(hello)的函数)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b)		<span class="comment">//undefined	</span></span><br></pre></td></tr></table></figure>

<p>此时在变量对象中的b并没有赋值，打印undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b=<span class="string">&quot;变量b的值&quot;</span></span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)		<span class="comment">//同样是 打印函数体内部有 console.log(hello)的函数</span></span><br><span class="line"><span class="built_in">console</span>.log(b)		<span class="comment">//变量b的值</span></span><br></pre></td></tr></table></figure>

<p>此时为变量b赋值为“变量b的值”，b的值不在是undefined·，打印结果为 “变量b的值”</p>
<p>此处的var a 可以理解成无效(就算删掉了var关键字，打印结果也是一样的)，因为代码执行到这以前对于变量a的申明，函数申明优先于变量申明，所以这个地方不会打印undefined 而是打印hello的那一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)		<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>这里为a 赋值为1，打印a，a不再是函数了，而是一个保存数值1的变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a()	//  a  is not a function</span></span><br></pre></td></tr></table></figure>

<p>如果这里把注释解开，真的去执行这行代码一定会报错的，a is not a function</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)		<span class="comment">// 打印函数体内部有 console.log(world)的函数</span></span><br><span class="line">a()		<span class="comment">//world</span></span><br></pre></td></tr></table></figure>

<p>在这里，变量a保存了一个函数，(这里相当于对变量a的一个赋值，和上面提到的函数申明是不一样的)</p>
<p>所以打印出一个函数（函数体内部有 console.log(world)的函数），当然此时可以执行a(), 执行函数体内部代码，打印出world</p>
<p><img src="/2021/09/26/%E6%B5%85%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(%E8%BF%9B%E9%98%B6)%EF%BC%88%E5%8C%85%E5%90%AB%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%81VO%E3%80%81AO%E7%AD%89%EF%BC%89/1.png" alt="1"></p>
<p>说完了第一个代码片段，下面来说说第二个代码片段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i  == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test2(i+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">test2(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>第二个代码片段就涉及到了<strong>上下文栈</strong>的相关内容，代码执行流进入test2(0)，创建test2(0)函数上下文并将其压如栈顶，此时看函数内部:i的值为0不等于3，所以代码继续执行，代码执行流进入test2(1),创建上下文，并压入栈顶(原本的test2(0)上下文被压入了栈中)，i的值为1不等于3，函数继续执行，test2(2)…test2(3),代码执行流进入test2(3)后，创建上下文，压入栈顶，代码执行…函数内部 i等于3满足条件，执行return语句，该上下文被弹出上下文栈。上下文栈控制权交给test2(2)，i的值为2，执行打印语句打印2，函数执行完毕出栈，将控制权交给test2(1), 打印1….控制权交给test2(0),打印0，test2(0)被弹出上下文栈被销毁。</p>
<p><img src="/2021/09/26/%E6%B5%85%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE(%E8%BF%9B%E9%98%B6)%EF%BC%88%E5%8C%85%E5%90%AB%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%81VO%E3%80%81AO%E7%AD%89%EF%BC%89/3.png" alt="3"></p>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>记录学习算法</title>
    <url>/2021/10/01/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h2><h4 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03.数组中重复的数字"></a>03.数组中重复的数字</h4><p><strong>长度为n的数组，里面数字范围在0~n-1范围内，找出重复数字</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getR</span>(<span class="params">nums</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp=<span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">while</span>(nums[i]!=i)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i]===nums[nums[i]])&#123;</span><br><span class="line">                   <span class="keyword">return</span> nums[i]</span><br><span class="line">               &#125;</span><br><span class="line">               temp=nums[nums[i]]</span><br><span class="line">               nums[nums[i]]=nums[i]</span><br><span class="line">               nums[i]=temp</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：数字范围在0~n-1，如果不重复的话每个数字刚好可以和下标一 一对应。所以，有数字重复的话就一定会有重复的数字和下标不匹配。遍历数组中每一个元素，确保元素和下标相等：如果当前元素和下标不相等，就让以当前元素为下标的元素和当前元素交换，用while循环来做，一直到元素和下标相等。之后继续遍历下一个元素，重复操作。一直到当前元素要和以当前元素为下标元素交换时，发现二者想等，则找出了重复的数字。</p>
<h4 id="变形："><a href="#变形：" class="headerlink" title="变形："></a>变形：</h4><p><strong>长度为n+1的数组，里面数字范围在1-n，不允许改变原数组，找出重复数字</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getR</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> end = nums.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> middle = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">        <span class="comment">//到最后一轮循环end和start是相邻的 差为1</span></span><br><span class="line">    <span class="keyword">while</span> (end &gt;= start) &#123;</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        middle = <span class="built_in">Math</span>.floor((start + end) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= start &amp;&amp; nums[i] &lt;= middle) &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; middle - start + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//最后一轮循环如果满足条件start为重复的数</span></span><br><span class="line">            <span class="keyword">if</span>(end-start===<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">            &#125;</span><br><span class="line">            end = middle</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当确定到最后两数之间时，如果不走if条件，即count不大于middle-start+1，说明重复的不是前个数字start而是后一个数字end</span></span><br><span class="line">            <span class="keyword">if</span> (end - start === <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> end</span><br><span class="line">            &#125;</span><br><span class="line">            start = middle</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找的思路：举个例子：数组长度为6(数组下标0-5)，数字范围是1-5，取中位数3，1-3中间有三个数，如果数组中在这个范围内的数字的个数大于三个，那么在1-3范围内一定有重复的数字，否则在3-5范围内有重复的数字，以此类推。注意：数字范围最大值和最小值之和不可以超过数组长度，否则取中位数后会偏大。</p>
<p>数字范围是1(start)~n(end)，只要end&gt;=start就要进入循环：取中位数middle，遍历整个数组确定大小在start和middle范围间数字出现的次数，如果该次数大于start到middle之间数字的个数，则在此范围内有重复的数，end=middle；否则，在middle到end范围内有重复的数字，start=middle，继续下一轮循环…确定middle的值…到最后一轮循环范围是两个相邻的数字，进入循环：此时的middle等于start，如果在数组中等于start或middle(start和middle范围内)的数字出现的次数&gt;1 (start和middle之间数字的个数count此时为1),那么start为重复的数字，否则end为重复的数字。</p>
<p>确定到最后与其说是范围不如说是两个数字。</p>
<h4 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04.二维数组中的查找"></a>04.二维数组中的查找</h4><p><strong>(medium)</strong></p>
<p><strong>在一个n*m的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> p2 = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= matrix.length - <span class="number">1</span> &amp;&amp; p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[p1][p2] &gt; target) &#123;</span><br><span class="line">                p2--</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[p1][p2] &lt; target) &#123;</span><br><span class="line">                p1++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个二位数组是从左到右，从上往下依次递增。每一行是越往后越大，每一列是越往下越大。所以确定范围从右上角元素开始筛。p1指向的是外层数组的第一个元素，p2指向的是内层数组的最后一个元素，p1,p2存储的都是下标。当前元素如果大于目标值，证明这一列都大于目标值，所以去掉这一列，p2指针–，进入下一轮判断。如果当前元素小于目标值，说明这一行都小于目标值，p1指针++，进入下一轮判断。每次判断的都是当前范围的右上角的元素，还是那句话，如果这个元素大于目标值，那么这一列都比目标值大，反之这一行都比目标值小，要舍弃这一行或一列，知道当前的元素不大于也不小于(等于)目标值，return true 退出循环。</p>
<p>最后要注意空数组的存在，如果输入一个空数组直接返回false。</p>
<h4 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05.替换空格"></a>05.替换空格</h4><p><strong>(双指针，easy)</strong></p>
<p><strong>请实现一个函数，把字符串中的每个空格替换成“%20”.例如，输入”We are happy”，则输出”We%20are%20happy”</strong></p>
<p>这一道题是为C++等其他类型语言设定的，当然用js同样可以实现，不过用js里的API实现会特别简单，就失去了这道题本身的精华所在。</p>
<p>js快速解题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceSpace=<span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            newStr += <span class="string">&#x27;%20&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newStr += s[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义了一个空的字符串newStr，遍历传入的s字符串，如果字符是空格，newStr+“%20”，否则+当前的字符s[i]。遍历结束返回newStr</p>
<p>js模拟C++的做法</p>
<p>最容想出来的暴力思路：统计字符串中空格的个数，扩充字符串的长度。从前往遍历字符串，每当遇到n个空格，遇到空格就添加n个“%20”，后面所有的元素都要往后移动2n个位置。再遇到，再移动…</p>
<p>书上的思路：统计字符串中空格的个数，扩充字符串的长度。从后往前遍历字符串，具体看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceSpace=<span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//这里需要扩充s的长度用来填充“%20”，要将s字符串转化为数组</span></span><br><span class="line">    s = s.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">//count用来统计字符串中空格的个数</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有空格原路返回</span></span><br><span class="line">    <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该指针指向数组中最后一个元素</span></span><br><span class="line">    <span class="keyword">let</span> oldIndex = s.length - <span class="number">1</span></span><br><span class="line">    <span class="comment">//对数组进行扩充</span></span><br><span class="line">    s.length += count * <span class="number">2</span></span><br><span class="line">    <span class="comment">//该指针指向扩充后的数组最后一个元素</span></span><br><span class="line">    <span class="keyword">let</span> newIndex = s.length - <span class="number">1</span></span><br><span class="line">    <span class="comment">//循环开始</span></span><br><span class="line">    <span class="keyword">while</span> (oldIndex &gt;= <span class="number">0</span> &amp;&amp; newIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果第一个指针所指向的元素(扩充前数组最后位置的元素)是空格，那么让第二个指针所指的元素依次往前赋值“0”“2”“%”</span></span><br><span class="line">        <span class="keyword">if</span> (s[oldIndex] === <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            s[newIndex--] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            s[newIndex--] = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">            s[newIndex--] = <span class="string">&#x27;%&#x27;</span></span><br><span class="line">            oldIndex--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则让第二个指针所指的元素直接赋值为第一个指针所指的元素值</span></span><br><span class="line">            s[newIndex--] = s[oldIndex--]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：合并两个数组或字符串。如果从前往后复制元素需要反复的移动重复的元素。而从后往前复制元素会减小移动次数，甚至不移动。这道题就巧妙地运用这一思路，第二个指针从后往前在不停的执行赋值操作。</p>
<h4 id="变形：-1"><a href="#变形：-1" class="headerlink" title="变形："></a>变形：</h4><p><strong>有两个排序的数组A1和A2，内存在A1的末尾有足够多的空余空间容纳A2。请实现一个函数，把A2中的所有数字插入A1中，并且所有的数字是排序的</strong></p>
<p>思路相同：从后往前复制元素。从后往前每次比较A1和A2的数字，A1中的元素从后往前赋值较大的数字</p>
<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><p><strong>(二分查找，easy)</strong></p>
<p><strong>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标直不存在于数组中，返回他将会被顺序插入的位置。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTarget</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> end = nums.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> middle = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        middle = <span class="built_in">Math</span>.floor((start + end) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">            start = middle + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">            end = middle - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> middle</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找思路：如果数组中不存在该数字，只有三种情况：要么在左边界插入，要么在右边界插入，要么最后确定两数中间。</p>
<p>在左边界：最后一轮循环middle=start=end=0，执行第二的if条件，end= -1，循环结束。返回start为插入位置</p>
<p>在右边界：同样在最后一轮循环middle=start=end= nums.length - 1，执行第一个if条件，start=最大索引＋1，循环结束。返回start为插入位置</p>
<p>在两数中间：在倒数第二轮循环里，middle=start，执行第一个if条件后start等于end，执行最后一轮循环：此时middle=start=end，执行第二个if语句，end-=1，循环结束，返回start作为插入位置。</p>
<h4 id="盛水最多容器"><a href="#盛水最多容器" class="headerlink" title="盛水最多容器"></a>盛水最多容器</h4><p><strong>(双指针，medium)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxArea = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right = height.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> area = <span class="built_in">Math</span>.min(height[left], height[right]) * (right - left)</span><br><span class="line">        maxArea = <span class="built_in">Math</span>.max(maxArea, area)</span><br><span class="line">        height[left] &lt; height[right] ? left++ : right--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用传统的双重for循环的话，时间复杂度太差会超时。所以用双指针求最大面积的思路：</p>
<p>开始left和right所指向的是数组两端元素，此时宽度最大，找出二者中最小的那一个元素作为高，此时的面积是以这个最小的元素为高的最大面积，以数组里面小于或等于这个元素作为高的面积就更比其小了。记录下这个面积，指针从最小元素那里往里移动一个单位，同样以较小元素为高，比较面积是否比原来的大，指针继续从最小元素那里往里移动。</p>
<p>三数之和</p>
<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p><strong>(先排序，双指针，medium)</strong></p>
<p><strong>给你一个包含n个整数的数组nums，判断nums中是否存在三个元素a，b，c，使得a+b+c=0 ？请你找出所有和为0且不重复的三元组</strong></p>
<p><strong>注意：答案中不可以包含重复的三元组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//对数组排序</span></span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">let</span> left = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> right = nums.length - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            sum = nums[i] + nums[left] + nums[right]</span><br><span class="line">            <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">                arr.push([nums[i], nums[left], nums[right]])</span><br><span class="line">                <span class="keyword">while</span> (left &lt;right &amp;&amp; nums[left] === nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                    left++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                    right--</span><br><span class="line">                &#125;</span><br><span class="line">                left++</span><br><span class="line">                right--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以一个数为基准，找两个伙伴，使得三者相加为0。首先对数组排序，遍历每一个元素，以该元素为基础，从数组中大于这个数的一侧利用双指针找出可以满足条件的三元组。至于为什么从一侧找，而不是便利整个数组？排序后，从当前元素“右面”查找另外两个元素，以此类推。这样就不会出现同样位置的三个元素构成的三元组，出现三次。以这样的方式查找，时间复杂度也会降低。在从当前元素“右面”这个区间里查找另外两个伙伴时，由于已经排序过，如果出现重复元素他们一定是相邻的，当满足sum=0时，判断两个指针所对应元素的相邻元素是否想的，如果相等，让相应的指针往里移动一个单位。可能有多个元素重复，所以要用while循环，这样避免存储三个元素都相同的三元组。当然不满足sum=0条件时，指针直接移动，不需要考虑是否重复。</p>
<h4 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h4><p><strong>(mediun)</strong></p>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    	<span class="comment">//起始指向第一个字符的指针</span></span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="comment">//记录无重复字符串的长度</span></span><br><span class="line">        <span class="keyword">let</span> len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">        <span class="keyword">while</span> (index &lt; s.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.has(s[index])) &#123;</span><br><span class="line">                <span class="comment">//存入map集合</span></span><br><span class="line">                map.set(s[index], index)</span><br><span class="line">                <span class="comment">//无重复字符 长度+1</span></span><br><span class="line">                len++</span><br><span class="line">                <span class="comment">//指针继续移动</span></span><br><span class="line">                index++</span><br><span class="line">                <span class="comment">//max存储最大长度</span></span><br><span class="line">                max = <span class="built_in">Math</span>.max(max, len)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//一旦发现出现重复字符，指针指向两个重复字符的第一个字符的下一位，从那个地方重新开始计算长度</span></span><br><span class="line">                <span class="comment">//比如 a b c d e f g h e i j...</span></span><br><span class="line">                <span class="comment">//e是重复的 从a开始计算长度，到第二个e发现重复，这是目前从a开始到第二个e前的最长无重复子串</span></span><br><span class="line">                <span class="comment">//从第一个e前面开始计算已经没有意义，后面已经重复再统计也是比原来短的子串，要从第一个e的下一个字符开始统计</span></span><br><span class="line">                index = map.get(s[index]) + <span class="number">1</span></span><br><span class="line">                len = <span class="number">0</span></span><br><span class="line">                <span class="comment">//出现重复字符后清空map集合</span></span><br><span class="line">                map.clear()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></h4><p><strong>(medium)</strong></p>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p>回文子串：对称的子串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.length === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">            <span class="keyword">let</span> right = <span class="number">0</span></span><br><span class="line">            <span class="keyword">let</span> result = s[<span class="number">0</span>]</span><br><span class="line">            <span class="comment">//遍历每一个字符，判断当前字符和下一个字符是否相等(偶数对称)，判断前一个字符和后一个字符是否相等奇数对称(奇数对称)，构成对称条件之后检测这个回			  //文串有多长</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">                <span class="comment">//每一轮都要尽行两次判断，如果是if else两个判断二选一会漏掉连续相等这种情况，会直接进入第一个判断比如“ccc”只会截取cc所以同时进行两个判断</span></span><br><span class="line">                <span class="comment">//取最长回文子串</span></span><br><span class="line">                left = i</span><br><span class="line">                right = i + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (s[left] === s[right]) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s[left] === s[right]) &#123;</span><br><span class="line">                            &#123;</span><br><span class="line">                                left--</span><br><span class="line">                                right++</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//slice 截取避开区间，从索引A截取到索引B（索引A，索引B+1）</span></span><br><span class="line">                    result = result.length &lt; s.slice(left + <span class="number">1</span>, right).length ? s.slice(left + <span class="number">1</span>, right) : result</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在进行第二个判断条件前要恢复left和right的值，因为在第一个判断条件里对left和right有加减擦操作。</span></span><br><span class="line">                left = i</span><br><span class="line">                right = i + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (s[left - <span class="number">1</span>] === s[right]) &#123;</span><br><span class="line">                    left--</span><br><span class="line">                    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s[left] === s[right]) &#123;</span><br><span class="line">                            &#123;</span><br><span class="line">                                left--</span><br><span class="line">                                right++</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result = result.length &lt; s.slice(left + <span class="number">1</span>, right).length ? s.slice(left + <span class="number">1</span>, right) : result</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Z-字形变换"><a href="#Z-字形变换" class="headerlink" title=" Z 字形变换"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/"> Z 字形变换</a></h4><p><strong>（medium)</strong></p>
<p><img src="/2021/10/01/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/Z%E5%9E%8B%E5%8F%98%E6%8D%A2.png" alt="Z型变换"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">numRows</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convert = <span class="function"><span class="keyword">function</span>(<span class="params">s, numRows</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (numRows === <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> s</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> len = <span class="built_in">Math</span>.min(s.length, numRows)</span><br><span class="line">                <span class="comment">//是否转头，初始化为false</span></span><br><span class="line">            <span class="keyword">let</span> turn = <span class="literal">false</span></span><br><span class="line">                <span class="comment">//把每一个(行)字符串存到数组中</span></span><br><span class="line">            <span class="keyword">let</span> arry = []</span><br><span class="line">                <span class="comment">//初始化数组，每一个元素都是一个空的字符串</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                arry[i] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> (str <span class="keyword">of</span> s) &#123;</span><br><span class="line">                arry[i] += str</span><br><span class="line">                <span class="comment">//判断当前位置是否在两端，如果在两端就要掉头，i就要  +1变成-1  或  -1变+1</span></span><br><span class="line">                <span class="keyword">if</span> (i === <span class="number">0</span> || i === arry.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    turn = !turn</span><br><span class="line">                &#125;</span><br><span class="line">                i += turn ? <span class="number">1</span> : -<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">of</span> arry) &#123;</span><br><span class="line">                result += i</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题说给定行数Z形排列，给定几行就创建几个(行)空的字符串，遍历给定的字符串s，每个(行)字符串依次从上往下添加一个字符，最后一个字符串添加字符之后，转头，从下往上依次添加字符，以此类推，从上到下，从下到上。</p>
<h4 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title=" 字符串转换整数 (atoi)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/"> 字符串转换整数 (atoi)</a></h4><p><strong>(medium)<img src="/2021/10/01/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0.png" alt="字符串转换整数"></strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="comment">//去掉空格</span></span><br><span class="line">            <span class="keyword">let</span> str = s.trim()</span><br><span class="line">            <span class="comment">//控制最后的正负号，最后返回的结果乘这个数</span></span><br><span class="line">            <span class="keyword">let</span> turn = <span class="number">1</span></span><br><span class="line">            <span class="comment">//保存结果</span></span><br><span class="line">            <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">            <span class="comment">//遍历的起始位置</span></span><br><span class="line">            <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">            <span class="comment">//第一个字符如果是负号，那么最后结果乘-1，遍历的起始位置start变成1</span></span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">0</span>] === <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                turn = -<span class="number">1</span></span><br><span class="line">                start = <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[<span class="number">0</span>] === <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//如果第一个字符是正好，那么最后还是乘-1 turn不变，遍历的起始位置start同样变成1</span></span><br><span class="line">                start = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="comment">// 也有第三种情况：第一个字符既不是正号也不是负号，就从头开始遍历start=0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; str.length; i++) &#123;</span><br><span class="line">				<span class="comment">//循环里面的判断条件是规定死的只要不是数字就不会拼接</span></span><br><span class="line">                <span class="keyword">if</span> (str[i] === <span class="string">&#x27; &#x27;</span> || !(str[i] * <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; str[i] &lt;= <span class="number">9</span>)) <span class="keyword">break</span></span><br><span class="line">                result += str[i]</span><br><span class="line">                <span class="comment">//如果计算结果超过范围直接退出，(字符串可以和数字进行比较)</span></span><br><span class="line">                <span class="keyword">if</span> (result &gt; <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (turn === -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result * turn</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输入的字符串可能第一个字符是正负号也可能不是，有的话从下一个开始遍历，知道不是数字为止。因为要遍历字符串，里面的条件我们是规定死的，所以分了三种情况，如果第一个字符是负号(正好或负号)，就从第二个开始遍历，否则正常遍历整个字符串。在里面我们规定的条件就是 如果字符不是数字直接跳出循环，只有字符才会被拼接</p>
<h4 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/">罗马数字转整数</a></h4><p><strong>(easy)</strong></p>
<p><img src="/2021/10/01/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0.png" alt="罗马数字转整数"></p>
<p>罗马数字是有规律的(个十百千位的规律是相同的)，比如 I是代表1；II代表2； III代表3；V是代表5；I在V前面，IV表示4；I在V后面，VI表示6，VII表示7；I只有在V(5)前面或X(10)前面表示-1，其余都是+1。一到十只有 I(1)，V(5)，X(10)  是固定的字符，其他都添加 I ，这个规律以此类推。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> romanToInt = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i + <span class="number">1</span>] === <span class="string">&#x27;V&#x27;</span> || s[i + <span class="number">1</span>] === <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                result += -<span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            result += <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&#x27;V&#x27;</span>) &#123;</span><br><span class="line">            result += <span class="number">5</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i + <span class="number">1</span>] === <span class="string">&#x27;L&#x27;</span> || s[i + <span class="number">1</span>] === <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">                result += -<span class="number">10</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            result += <span class="number">10</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">            result += <span class="number">50</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i + <span class="number">1</span>] === <span class="string">&#x27;D&#x27;</span> || s[i + <span class="number">1</span>] === <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">                result += -<span class="number">100</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            result += <span class="number">100</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">            result += <span class="number">500</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            result += <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/">整数转罗马数字</a></h4><p><strong>(medium)</strong></p>
<p><img src="/2021/10/01/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0.png" alt="整数转罗马数"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">num</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intToRoman = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> arry1 = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;MM&#x27;</span>, <span class="string">&#x27;MMM&#x27;</span>]</span><br><span class="line">            <span class="keyword">let</span> arry2 = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;CC&#x27;</span>, <span class="string">&#x27;CCC&#x27;</span>, <span class="string">&#x27;CD&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;DC&#x27;</span>, <span class="string">&#x27;DCC&#x27;</span>, <span class="string">&#x27;DCCC&#x27;</span>, <span class="string">&#x27;CM&#x27;</span>]</span><br><span class="line">            <span class="keyword">let</span> arry3 = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;XX&#x27;</span>, <span class="string">&#x27;XXX&#x27;</span>, <span class="string">&#x27;XL&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;LX&#x27;</span>, <span class="string">&#x27;LXX&#x27;</span>, <span class="string">&#x27;LXXX&#x27;</span>, <span class="string">&#x27;XC&#x27;</span>]</span><br><span class="line">            <span class="keyword">let</span> arry4 = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;II&#x27;</span>, <span class="string">&#x27;III&#x27;</span>, <span class="string">&#x27;IV&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;VI&#x27;</span>, <span class="string">&#x27;VII&#x27;</span>, <span class="string">&#x27;VIII&#x27;</span>, <span class="string">&#x27;IX&#x27;</span>]</span><br><span class="line">            <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            str += arry1[<span class="built_in">Math</span>.floor(num / <span class="number">1000</span>)]</span><br><span class="line">            num = num % <span class="number">1000</span></span><br><span class="line">            str += arry2[<span class="built_in">Math</span>.floor(num / <span class="number">100</span>)]</span><br><span class="line">            num = num % <span class="number">100</span></span><br><span class="line">            str += arry3[<span class="built_in">Math</span>.floor(num / <span class="number">10</span>)]</span><br><span class="line">            num = num % <span class="number">10</span></span><br><span class="line">            str += arry4[num]</span><br><span class="line">            <span class="keyword">return</span> str</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><p><strong>(medium)</strong></p>
<p><img src="/2021/10/01/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.png" alt="电话号码的字母组合"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">digits</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> letterCombinations = <span class="function"><span class="keyword">function</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> map = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!digits) &#123;</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> result = []</span><br><span class="line">			<span class="comment">//回调的参数是上一轮拼接好的字符串(进入本轮继续拼接，再传到下一轮)，和digits字符串(输入的电话号码)的索引</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">callBack</span>(<span class="params">str, index</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//当index为digits的长度时，说明该分支已经到底了，这时将该分支得到的字符串str推入数组，回头去执行下一轮循环</span></span><br><span class="line">                <span class="keyword">if</span> (index === digits.length) &#123;</span><br><span class="line">                    result.push(str)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//遍历每数字对应的每一个字符</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map[digits[index]]) &#123;</span><br><span class="line">                    <span class="comment">//每次遍历一个字符，str(上一轮拼接好的字符串)就会拼接字符，继续调用回调，此时index指向下一个数字...</span></span><br><span class="line">                    callBack(str + item, index + <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            callBack(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行顺序：举个例子（大概思路，没有考虑初始str为 ‘ ’）：传入‘234’  , 对应三个字符串 ‘abc’ , ‘def’ , ‘ghi’  第一层循环(第一轮)，str=a，执行回调进入第二层循环(第一轮)，str=ad,执行回调进入第三层循环(第一轮)，str=adg return掉回调函数不再执行，第二轮str=adh，第三轮str=adi,return掉回调函数不再执行。返回第二层循环，str=ae,继续回调str=aeg，str=aeh，str=aei…，都是到最后回调被return掉结束循环。</p>
<h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h4><p><img src="/2021/10/01/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90.png" alt="括号生成"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bfs</span>(<span class="params">str, Ln, Rn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Ln &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            bfs(str + <span class="string">&#x27;(&#x27;</span>, Ln - <span class="number">1</span>, Rn)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Rn &gt; Ln) &#123;</span><br><span class="line">            bfs(str + <span class="string">&#x27;)&#x27;</span>, Ln, Rn - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Ln === <span class="number">0</span> &amp;&amp; Rn === <span class="number">0</span>) &#123;</span><br><span class="line">            result.push(str)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bfs(<span class="string">&#x27;&#x27;</span>, n, n)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h4><p><strong>(easy)</strong></p>
<p><img src="/2021/10/01/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.png"></p>
<p>括号只可以是一对一对出现，可以有包含关系如示例5，但不可以出现示例4那种情况，所以在遍历字符串时，第一个闭回的右括号一定对应最后一个左括号(目前遍历过的)。如：（ [ ]  {  ( )  } ）采用栈的思想：遍历字符串，把左括号不断地压栈，直到第一个右括号出现，把处于栈顶的左括号(目前最后一次入栈的字符)弹出栈顶，如果下一个是左括号就继续压栈，是右括号就弹出当前栈顶的左括号。整个过程要确保每次左右括号都匹配才可以出栈，每一对都匹配，到最后栈是空的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果字符串的字符数是奇数个肯定不满足闭回条件，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (s.length % <span class="number">2</span> === <span class="number">1</span> || !s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保对应的类型，右，左 括号以键值对形式存入map集合</span></span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">        [<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>]</span><br><span class="line">    ])</span><br><span class="line">    <span class="keyword">const</span> stk = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="comment">//判断是否是右括号</span></span><br><span class="line">        <span class="keyword">if</span> (map.has(item)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk[stk.length - <span class="number">1</span>] === map.get(item)) &#123;</span><br><span class="line">                stk.pop()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//左括号直接入栈</span></span><br><span class="line">            stk.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stk.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><p><img src="/2021/10/01/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.png" alt="合并两个有序链表"></p>
<p>迭代</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> newNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">let</span> p = newNode</span><br><span class="line">            <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                    p.next = l1</span><br><span class="line">                    l1 = l1.next</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.next = l2</span><br><span class="line">                    l2 = l2.next</span><br><span class="line">                &#125;</span><br><span class="line">                p=p.next</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = l1 === <span class="literal">null</span> ? l2 : l1</span><br><span class="line">            <span class="keyword">return</span> newNode.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1 === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> l2</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> l1</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                l1.next = mergeTwoLists(l1.next, l2)</span><br><span class="line">                <span class="keyword">return</span> l1</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l2.next = mergeTwoLists(l1, l2.next)</span><br><span class="line">                <span class="keyword">return</span> l2</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="牛客上看到的"><a href="#牛客上看到的" class="headerlink" title="牛客上看到的"></a>牛客上看到的</h2><p>找出字符串strA中 字符串strB出现的次数，如：strA：“aaaa”，strB：”aa” 出现两次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getNum = <span class="function"><span class="keyword">function</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//记录indexOf方法的返回值</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="comment">//每次要开始搜索的索引</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">//记录子串出现次数</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">        i = str1.indexOf(str2, index)</span><br><span class="line">         <span class="comment">//相加等于索引加1，为下次的起始位置</span></span><br><span class="line">        index = i + str2.length</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无论是最后一轮循环查找还是原本str1中就没有str2(一轮游)，都会使i变成-1，count+1后才退出循环</span></span><br><span class="line">    <span class="keyword">return</span> count - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>关于算法</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中构造函数和普通函数的区别</title>
    <url>/2021/10/12/JS%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p> 构造函数也是函数，来看代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name</span><br><span class="line">    Person.prototype.age=<span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建实例对象</span></span><br><span class="line"><span class="keyword">let</span> p=<span class="keyword">new</span> Person(<span class="string">&#x27;Kobe&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.name)		<span class="comment">//	Kobe</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age)		<span class="comment">//	16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用普通函数</span></span><br><span class="line">getName()		<span class="comment">//	Kobe</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数也是函数，不难看出构造函数和普通函数的定义方式是一样的。</strong></p>
<p>构造函数和普通函数的唯一区别在于二者的调用方式和用途不用：</p>
<ul>
<li><strong>构造函数通过new关键字来调用，用来创建实例对象</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建实例对象</span></span><br><span class="line"><span class="keyword">let</span> p=<span class="keyword">new</span> Person(<span class="string">&#x27;Kobe&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>普通函数直接调用，是用来执行特定任务的代码块</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用普通函数</span></span><br><span class="line">getName()</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>通过new关键字来调用构造函数会执行如下操作：</strong></p>
<p><strong>1.在堆内存中创建一个新的对象</strong></p>
<p><strong>2.this指向这个新对象</strong></p>
<p><strong>3.执行函数中的代码(通过this语句为新对象添加属性)</strong></p>
<p><strong>4.返回这个新对象</strong></p>
<p>上述执行操作第四点需要注意的是：如果在构造函数中执行return语句，并返回一个非空对象，那么构造函数执行完毕后会将这个对象返回，并不会返回在堆内存中创建的新对象。看如下示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name</span><br><span class="line">    Person.prototype.age=<span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">msg</span>:<span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建实例对象</span></span><br><span class="line"><span class="keyword">let</span> p=<span class="keyword">new</span> Person(<span class="string">&#x27;Kobe&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p)		<span class="comment">//	&#123;msg: &quot;hello world&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里的构造函数执行return语句返回了非空对象：{msg: “hello world”}，最终构造函数会返回该对象，并不会返回在堆内存中创建的新对象。如果return语句返回的不是非空对象而是其他值，又或者没有return语句，则返回堆内存中创建的对象。</p>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的原型和原型链</title>
    <url>/2021/10/12/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h3 id="构造函数、实例、原型三者的关系"><a href="#构造函数、实例、原型三者的关系" class="headerlink" title="构造函数、实例、原型三者的关系"></a>构造函数、实例、原型三者的关系</h3><p><strong>在JavaScript中每创建一个函数，就会为这个函数创建一个prototype属性，该属性指向函数的原型对象，而这个原型对象在默认情况下会有一个名为constructor的属性指回构造函数。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拿到Person的原型对象</span></span><br><span class="line"><span class="keyword">let</span> pro=Person.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">//给原型添加属性</span></span><br><span class="line">pro.name=<span class="string">&quot;Kobe&quot;</span></span><br><span class="line">pro.age=<span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//验证Person的原型对象的constructor属性是否指回Person</span></span><br><span class="line"><span class="built_in">console</span>.log(pro.constructor===Person)		<span class="comment">//	true</span></span><br></pre></td></tr></table></figure>

<p><strong>通过构造函数来创建实例，该实例内部的__ proto__属性也会指向构造函数的原型对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">let</span> p2=<span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p1.__proto__===Person.prototype)		<span class="comment">//	true</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.__proto__===Person.prototype)		<span class="comment">//	true</span></span><br></pre></td></tr></table></figure>

<p>看图说话：</p>
<p><img src="/2021/10/12/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/1.png" alt="1"></p>
<h3 id="通过实例来修改原型上的属性"><a href="#通过实例来修改原型上的属性" class="headerlink" title="通过实例来修改原型上的属性"></a>通过实例来修改原型上的属性</h3><ul>
<li><strong>如果修改的是保存引用值的属性上的一个或多个属性，则会修改原型上的属性</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.prototype.msg = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.color=[<span class="string">&#x27;yellow&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p=<span class="keyword">new</span> Person()</span><br><span class="line">p.msg.name=<span class="string">&quot;李四&quot;</span></span><br><span class="line">p.msg.age=<span class="number">30</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.msg)		<span class="comment">//	&#123;name: &quot;李四&quot;, age: 30&#125;</span></span><br><span class="line">p.color.push(<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.color)		<span class="comment">//	[&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;black&#x27;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果修改的是保存原始值的属性，或直接将保存引用值的属性“整个儿换掉”,则不会修改原型上的属性，而是直接在实例对象上直接添加我们修改的属性</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.prototype.name = <span class="string">&quot;Kobe&quot;</span></span><br><span class="line">    Person.prototype.job = &#123;</span><br><span class="line">        <span class="attr">salary</span>: <span class="string">&#x27;30k&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person()</span><br><span class="line">p.name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">p.job = &#123;</span><br><span class="line">    <span class="attr">str</span>:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__)</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="/2021/10/12/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/2.png" alt="2"></p>
<p><img src="/2021/10/12/JS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/Users/86137/AppData/Roaming/Typora/typora-user-images/image-20211012170546814.png" alt="image-20211012170546814"></p>
<p>很明显，对于这种情况只会把要“修改的属性”添加到自身</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><blockquote>
<p>每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想                                                                                                                                                                                ——《JavaScript高级程序设计第四版》</p>
</blockquote>
<p>原型解决了数据共享问题，即多个实例共享原型上的数据。那么如果不同的构造函数所创建的实例要想共享数据呢？原型链就可以解决这个问题。</p>
<p><strong>做个假设：A实例要想要想从毫不相干的B实例身上取数据。</strong></p>
<p>如果想要实现这种效果，我们可以把A类型的prototype属性指向B类型的实例，即重写A的原型对象为B实例对象，这样就实现了一种继承关系。如果想要通过A实例查找某一属性，会先从自身找，找不到会从原型对象(B实例)上找，找不到继续在原型对象的原型对象(B实例的原型对象)上找…这个查找过程就是在原型链上查找的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    B.prototype.num = <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写A类型的原型</span></span><br><span class="line">A.prototype = <span class="keyword">new</span> B()</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建A实例</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.num)      <span class="comment">//  12</span></span><br></pre></td></tr></table></figure>

<h3 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h3><p>任何一个函数的原型默认都是一个Object类型的实例，所以原型的__ proto__会指向 Object.prototype(即Object构造函数的原型)，Object的原型的原型为null，即原型链的尽头。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cf</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Cf()</span><br><span class="line">    <span class="comment">//这里c是Cf类型的实例，而c的原型默认是Object类型的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(c.__proto__ <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(c.__proto__.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise学习笔记：Promise、then和catch方法</title>
    <url>/2021/10/20/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9APromise%E3%80%81%20then%E5%92%8Ccatch%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><strong>Promise是ES6新增的引用类型，通过new来实例化时需要传入执行器函数(executor)作为参数，这个执行器函数内部可以封装异步操作。</strong></p>
<p>Promise类的实例对象是有<strong>状态(state)<strong>的，对应三个值：</strong>pedding(待定</strong>)、<strong>fullfilled(成功)<strong>、</strong>rejected(失败)</strong></p>
<p>(实例的初始状态为pedding，一旦由pedding状态落定成fulfilled状态或rejected状态，就不可再次改变，该过程是不可逆的）</p>
<p>与之对应，Promise类实例对象有**成功的结果(value)<strong>和</strong>失败的原因(reason)**，默认值都为undefined，只有状态被改变后(从初始默认状态落定成功或失败的状态)才会为其赋值。</p>
<p><strong>注意：Promsie内部的state、value、reason是私有的，外界是访问不到的</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向里面传入执行器函数，执行器函数默认两个参数对应改变状态的两个函数</span></span><br><span class="line"><span class="keyword">let</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...一系列操作...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//改变实例的状态：pedding-&gt;fulfilled，成功的结果value为“我是成功的结果”</span></span><br><span class="line">    resolve(<span class="string">&quot;我是成功的结果&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/20/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9APromise%E3%80%81%20then%E5%92%8Ccatch%E6%96%B9%E6%B3%95/1.png" alt="1"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向里面传入执行器函数，执行器函数默认两个参数对应改变状态的两个函数</span></span><br><span class="line"><span class="keyword">let</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//...一系列操作...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//改变实例的状态：pedding-&gt;rejected，失败的原因reason为“我是失败的原因”</span></span><br><span class="line">    reject(<span class="string">&quot;我是失败的原因&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/20/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9APromise%E3%80%81%20then%E5%92%8Ccatch%E6%96%B9%E6%B3%95/2.png" alt="2"></p>
<p>正如开头说的，在我们实例化一个Promise时会传入一个执行器函数来进行一系列的操作，这个执行器函数接受两个参数：resolve、reject他们都是回调函数，用来落定状态。在这个执行器函数里面就可以根据这一系列的操作的实际情况通过这两个回调来规定该实例对象的状态是fulfilled(成功)，还是rejected(失败)，并设置成功的结果或失败的原因。</p>
<hr>
<p>上面说到Promise内部的值是私有的，那么外部代码需要访问这个成功或失败的值呢？这时候就需要Promsie类为我们提供的方法了。</p>
<h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><ul>
<li><strong>then()</strong></li>
</ul>
<p>在原型上的then方法<strong>最多接收两个参数</strong>，<strong>onResolved处理程序</strong>和<strong>onRejected处理程序</strong>，都是可选的。通过这两个参数我们可以拿到实例成功或失败的结果。同时then方法也会返回一个新的Promise实例对象(下面一律称为promise2)。</p>
<p><strong>注意：只有Promsie内部的状态落定了，then方法中对应的处理程序才会执行。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向里面传入执行器函数，执行器函数默认两个参数对应改变状态的两个函数</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//改变实例的状态：pedding-&gt;fulfilled，成功的结果value为“我是成功的结果”</span></span><br><span class="line">    reject(<span class="string">&quot;我是失败的原因&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="literal">undefined</span>, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//打印 “我是失败的原因”</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>链式调用</strong></li>
</ul>
<p>上面说到then方法返回一个新的Promise实例，那么就再次可以使用then方法，不断地.then().then()，以此类推：new Promsie((res,rej)=&gt;(res(‘bar’))).then().then().then() … ,这就是then方法的强大之处，可以<strong>链式调用</strong></p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个函数，里面有两个参数，str和回电函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">str, callback = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//一秒后打印str，并执行回调函数</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(str)</span><br><span class="line">        <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">            callback()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&#x27;你&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fn(<span class="string">&#x27;好&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn(<span class="string">&#x27;啊&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">// 你（1秒后）</span></span><br><span class="line"><span class="comment">// 好（2秒后）</span></span><br><span class="line"><span class="comment">// 啊（3秒后）</span></span><br></pre></td></tr></table></figure>

<p>这里只有三次回调，真实的业务要比这复杂得多，那么回调会更多。如果没有更方便更直观的方法，那么就这样一直回调，回调，回调……</p>
<p>下面使用Promise实现的同样的功能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str)</span><br><span class="line">            res()</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fn2(<span class="string">&#x27;你&#x27;</span>)</span><br><span class="line">    .then(<span class="function">() =&gt;</span></span><br><span class="line">        fn2(<span class="string">&#x27;好&#x27;</span>)</span><br><span class="line">    ).then(<span class="function">() =&gt;</span></span><br><span class="line">        fn2(<span class="string">&#x27;啊&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">// 你（1秒后）</span></span><br><span class="line"><span class="comment">// 好（2秒后）</span></span><br><span class="line"><span class="comment">// 啊（3秒后）</span></span><br></pre></td></tr></table></figure>

<p>这里面虽然没有通过链式调用来拿上一次的结果，但是就这个例子而言已经可以看出相比上面的写法通过promise更为直观。then里面的处理程序会等待前一个实例解决，然后实例化一个新的实例并返回，这样可以串行异步任务。</p>
<hr>
<p>说到then返回一个新的promsie实例，那么then方法返回一个什么样的promise实例呢，里面是成功的还是失败的呢？下面总结了几个规则：</p>
<ul>
<li>then方法内没有传入相应的处理程序，或者原promise处于pedding状态都会返回一个和原来相同的promsie2（虽然二者看起来一样，但是指针指向的不是同一个对象）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    rej(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(A.then())</span><br><span class="line"><span class="built_in">console</span>.log(A.then(<span class="function">()=&gt;</span>&#123;&#125;,<span class="literal">undefined</span>))</span><br><span class="line"><span class="built_in">console</span>.log(A)</span><br><span class="line"><span class="built_in">console</span>.log(A===A.then())</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/20/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9APromise%E3%80%81%20then%E5%92%8Ccatch%E6%96%B9%E6%B3%95/3.png" alt="3"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        rej(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = A.then(<span class="literal">undefined</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;111&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//此时原本的A实例处于pending状态，处理程序没有执行，打印的then方法返回的promise2也处于pedding状态</span></span><br><span class="line"><span class="built_in">console</span>.log(promise2)</span><br><span class="line"><span class="comment">//定时四秒超时后A的状态早已落定，then执行了onResolved处理程序(为啥返回结果不一样呢，往下看)</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(promise2)</span><br><span class="line">    &#125;, <span class="number">4000</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/20/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9APromise%E3%80%81%20then%E5%92%8Ccatch%E6%96%B9%E6%B3%95/10.png" alt="10"></p>
<ul>
<li><p>对应的位置传入了处理程序(看返回值)：<br>（1）如果对应的处理程序返回值不是一个promsie对象，那么返回的promise2对象执行了resolve(处理程序的返回值)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    res(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = A.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我拿到了成功的结果&#x27;</span> + value)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是promise2的结果&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise2)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/20/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9APromise%E3%80%81%20then%E5%92%8Ccatch%E6%96%B9%E6%B3%95/4.png" alt="4"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    rej(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = A.then(<span class="literal">undefined</span>, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我拿到了失败的原因&#x27;</span> + reason)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是promise2的结果&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise2)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/20/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9APromise%E3%80%81%20then%E5%92%8Ccatch%E6%96%B9%E6%B3%95/5.png" alt="5"></p>
<p>（2）如果对应的处理程序的返回值是一个promsie对象，返回这个promsie对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    rej(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = A.then(<span class="literal">undefined</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">        res(<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise2)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2021/10/20/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9APromise%E3%80%81%20then%E5%92%8Ccatch%E6%96%B9%E6%B3%95/6.png" alt="6"></p>
<p>​    </p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    rej(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = A.then(<span class="literal">undefined</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//无结果</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise2)</span><br></pre></td></tr></table></figure>



<p><img src="/2021/10/20/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9APromise%E3%80%81%20then%E5%92%8Ccatch%E6%96%B9%E6%B3%95/7.png" alt="7"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    rej(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = A.then(<span class="literal">undefined</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">        rej(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise2)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/20/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9APromise%E3%80%81%20then%E5%92%8Ccatch%E6%96%B9%E6%B3%95/8.png" alt="8"></p>
<p>（3）执行对应处理程序出现异常，返回的promsie2执行了reject(e)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    rej(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = A.then(<span class="literal">undefined</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错啦&#x27;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise2)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/20/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9APromise%E3%80%81%20then%E5%92%8Ccatch%E6%96%B9%E6%B3%95/9.png" alt="9"></p>
<h2 id="Promise-protorype-catch"><a href="#Promise-protorype-catch" class="headerlink" title="Promise.protorype.catch"></a>Promise.protorype.catch</h2><p>catch方法就是一个语法糖，只接收一个参数，onRejected处理程序。他的作用和调用Promise.prototype.then(null,onRejected)是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//打印一个未定义的变量，这里会出错</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    res()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台是一样的结果</span></span><br><span class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(reason))</span><br><span class="line">promise.catch(<span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(reason))</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/20/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9APromise%E3%80%81%20then%E5%92%8Ccatch%E6%96%B9%E6%B3%95/11.jpg" alt="11"></p>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构--栈</title>
    <url>/2021/10/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
    <content><![CDATA[<h2 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a>什么是栈？</h2><p>栈是一种遵循<strong>后进先出(LIFO)<strong>原则的有序集合。栈的两端分别叫做：</strong>栈顶</strong>，<strong>栈底</strong>。最先入栈的元素被压入栈底，新添加的元素会保持在栈顶。在栈中，越先入栈的元素越接近栈底，越后入栈的元素越靠近栈顶。</p>
<p>这个结构类似于一个水桶，先放进去的东西被压在下面，而后放进去的东西反而在顶部，是最先被拿出来的。</p>
<p><img src="/2021/10/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/1.png" alt="1"></p>
<p>这里A先入栈，一定是最后出栈的，F最后入栈，处于栈顶，一定最先出栈。</p>
<hr>
<h2 id="创建一个栈"><a href="#创建一个栈" class="headerlink" title="创建一个栈"></a>创建一个栈</h2><p>(这里没有考虑私有属性)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">//存如栈的元素以键值对的形式保存到_items中</span></span><br><span class="line">            <span class="built_in">this</span>._items = &#123;&#125;</span><br><span class="line">            <span class="built_in">this</span>._count = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>push(element)方法，向栈中压入元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Stack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//元素存入items对象中，_count为键，值为element，存储之后count+1表示长度</span></span><br><span class="line">    <span class="built_in">this</span>._items[<span class="built_in">this</span>._count++] = element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>size()方法，返回栈的大小</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Stack.prototype.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isEmpty()方法，判断栈是否为空，为空则返回true否则返回false</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Stack.prototype.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//长度为0返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._count === <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pop()方法，移除栈顶元素，并返回移除的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Stack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._count--</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">this</span>._items[<span class="built_in">this</span>._count]</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>._items[<span class="built_in">this</span>._count]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>peak()方法，该方法会返回栈顶元素，用来查看栈顶元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Stack.prototype.peak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._items[<span class="built_in">this</span>._count - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clear()方法，清空栈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Stack.prototype.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._items = &#123;&#125;</span><br><span class="line">    <span class="built_in">this</span>._count = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>toString()方法，返回栈内容的字符串形式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Stack.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">this</span>._items[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>._count; i++) &#123;</span><br><span class="line">        result += <span class="string">&quot;,&quot;</span> + <span class="built_in">this</span>._items[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="用栈来解决问题"><a href="#用栈来解决问题" class="headerlink" title="用栈来解决问题"></a>用栈来解决问题</h2><p><strong>进制转换算法</strong></p>
<p>可以将指定数字转换成任意进制的数字，比如将指定数字10转换成2进制数字</p>
<p><img src="/2021/10/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/2.png" alt="2"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decimalToBinary</span>(<span class="params">decNumber</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line">    <span class="keyword">let</span> num = decNumber</span><br><span class="line">        <span class="comment">//保存余数</span></span><br><span class="line">    <span class="keyword">let</span> rem = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        rem = <span class="built_in">Math</span>.floor(num % <span class="number">2</span>)</span><br><span class="line">        stack.push(rem)</span><br><span class="line">        <span class="comment">//保存商，下一轮还要用商继续除</span></span><br><span class="line">        num = <span class="built_in">Math</span>.floor(num / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> len = stack.size()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        result += stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>关于数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise学习笔记：finally、all、race方法</title>
    <url>/2021/10/23/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Afinally%E3%80%81all%E3%80%81race%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h2><p>该方法接收一个onFinally处理程序作为参数，不同于then和catch方法，该方法不关心最后落定成什么状态，只要状态由默认状态落定成功状态或失败状态，该处理程序都会执行。该方法不关心最后的结果，所以onFinally处理程序不接受参数，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        res(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我执行啦&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台打印</span></span><br><span class="line"><span class="comment">//我执行啦(3秒后)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        rej()</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我执行啦&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台打印</span></span><br><span class="line"><span class="comment">//我执行啦(3秒后)</span></span><br></pre></td></tr></table></figure>

<p>返回值：大多数情况该方法回原样返回父Promsie实例，但是如果处理程序返回一个pedding状态的实例或处理程序内部抛出错误(显示抛出或返回一个拒绝promsie)则会返回相应的promsie实例(待定或拒绝)</p>
<hr>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>该方法的参数是一个可迭代对象，内部的<strong>全部</strong>的promsie<strong>解决</strong>后才会返回解决的promise实例。解决的结果就是每一个promise解决结果构成的数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建几个解决的promsie实例</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了这几个解决的promise可迭代对象中还添加了数字2</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.all([promise1, promise2, promise3，<span class="number">2</span>])</span><br><span class="line"><span class="built_in">console</span>.log(promise)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/23/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Afinally%E3%80%81all%E3%80%81race%E6%96%B9%E6%B3%95/1.png" alt="1"></p>
<p>这里要注意的是，就算可迭代对象中添加的不是promise实例也会由Promsie.resolve方法包装成解决的promise实例</p>
<p>当然也有可迭代对象中不全是解决的promise实例的情况，继续看例子：</p>
<ul>
<li><p>有拒绝promsie的情况,就返回这个拒绝的promsie的镜像(如果有多个拒绝，则返回第一个)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成功的promsie实例</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//失败的promsie实例</span></span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;失败啦&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise4 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;又又又失败啦&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.all([promise1, promise2, promise3, promise4, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">console</span>.log(promise)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/23/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Afinally%E3%80%81all%E3%80%81race%E6%96%B9%E6%B3%95/2.png" alt="2"></p>
</li>
<li><p>有处于pedding的promsie，就返回的promsie实例也处于pedding状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> promise5 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="comment">// let promise3 = Promise.reject(&#x27;失败啦&#x27;)</span></span><br><span class="line">    <span class="comment">// let promise4 = Promise.reject(&#x27;又又又失败啦&#x27;)</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.all([promise1, promise2, promise5])</span><br><span class="line"><span class="built_in">console</span>.log(promise)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2021/10/23/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Afinally%E3%80%81all%E3%80%81race%E6%96%B9%E6%B3%95/3.png" alt="3"></p>
<ul>
<li><p>可迭代对象的元素既有promsie实例也有处于pedding状态的实例，还是返回拒绝的promsie的镜像</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> promise5 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;失败啦&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise4 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;又又又失败啦&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.all([promise1, promise2, promise3, promise4, promise5])</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2021/10/23/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Afinally%E3%80%81all%E3%80%81race%E6%96%B9%E6%B3%95/2.png" alt="2"></p>
<hr>
<h2 id="Promsie-race"><a href="#Promsie-race" class="headerlink" title="Promsie.race"></a>Promsie.race</h2><p>这个方法正好和all方法相反，返回的新promise是这组可迭代对象中<strong>最先</strong>解决或拒绝的promise的镜像。普通的值同样会用Promise.resolve()包装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        res(<span class="string">&#x27;YES&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;NO&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.race([promise1, promise2])</span><br></pre></td></tr></table></figure>

<p><img src="file:///C:\Users\86137\AppData\Roaming\Tencent\Users\2235253716\QQ\WinTemp\RichOle\HW0HTVJ}NFJXV8}H]7N6P{1.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        res(<span class="string">&#x27;YES&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;NO&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.race([promise1, promise2])</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/23/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Afinally%E3%80%81all%E3%80%81race%E6%96%B9%E6%B3%95/5.png" alt="5"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        rej(<span class="string">&#x27;NO&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        rej(<span class="string">&#x27;~~~~~~~NO&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.race([promise1, promise2])</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时打印的promsie是处于pedding状态的</span></span><br><span class="line"><span class="built_in">console</span>.log(promise)</span><br><span class="line"></span><br><span class="line"><span class="comment">//四秒后打印promise</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(promise)</span><br><span class="line">&#125;, <span class="number">4000</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/23/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Afinally%E3%80%81all%E3%80%81race%E6%96%B9%E6%B3%95/6.png" alt="6"></p>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构--树、二叉树</title>
    <url>/2021/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树是一种分层次数据的抽象模型，下图是在现实生活中的例子：</p>
<p><img src="/2021/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91/1.png" alt="1"></p>
<p>在图中不难看出一个家族里要长幼有序，不能乱了辈分，这就是树在现实生活中的表现形式。</p>
<h2 id="树的结构"><a href="#树的结构" class="headerlink" title="树的结构"></a>树的结构</h2><p><img src="/2021/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91/2.png" alt="2"></p>
<p>结点的深度：结点的深度取决于祖先节点的个数，比如：4结点的结点深度为2</p>
<p>树的高度：树的高度是最大的结点深度，取决于所有节点中深度最大的结点。这棵树的高度为2</p>
<hr>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是一种特殊的树，它的结点最多有两个，分别是左节点和又结点。当然也可以只有一个结点或不包含结点。</p>
<ul>
<li><h5 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树(BST)"></a>二叉搜索树(BST)</h5></li>
</ul>
<p>二叉搜索树是一种特殊的二叉树，是二叉树的一种，特点是左节存储的值点要比父节点小，右结点存储的值要比父节点大</p>
]]></content>
      <categories>
        <category>关于数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>JS实现防抖与节流</title>
    <url>/2021/11/03/JS%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>我们可以想象一下：对于一个要输入信息的输入框，我们最终想要输入的肯定是在输入完成时输入框中的整个字符串去触发响应，那么对于这个过程，响应如果不加以限制我们在每次输入一个字符后都会触发响应，如果频繁的输入字符或者删除字符就会造成响应卡顿。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Input = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;Input&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Input.value)</span><br><span class="line">&#125;</span><br><span class="line">Input.onkeydown = test</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/JS%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/1.png" alt="1"></p>
<p>很明显，我们最终输入的是‘AAAAAAAAA’,而操作却执行了9次。这个例子很简单，但我们假设如果是一个触发频率极高的事件，并涉及到大量的计算操作相关的内容，会对服务器造成很大的压力。</p>
<p><strong>防抖(debounce)和节流(throttling)是两种解决对于频繁触发DOM事件而造成响应卡顿的方案</strong></p>
<h3 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h3><p>原理：设定一个周期去延迟执行响应操作，如果频繁的触发事件，那么会继续延期执行，直到一段时间不在触发事件才会执行响应的操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">500</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//这里维护一个变量timer</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="comment">//根据定时器id清空了定时器，但是timer变量存储的id值不变</span></span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果频繁的去触发操作，那么每次执行匿名函数都会清空上一次执行的定时器，直到最后一次</p>
<p>关键是在外层函数中维护了一个timer变量，每次触发返回的匿名函数都会以外面维护的变量为参照，去判断是否需要清空定时器。每次触发返回的匿名函数都会开辟一块新的空间，他们是相互独立的，但是这里应用了闭包的思想，每次执行匿名函数都会访问同一个timer。    ·</p>
<p>用防抖去解决上面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里直接将keyup事件的回调设置为 debounce函数返回的匿名函数，这个匿名函数里面执行了test回调</span></span><br><span class="line">Input.onkeydowm = debounce(test)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/03/JS%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/2.png" alt="2"></p>
<h3 id="立即执行-升级版"><a href="#立即执行-升级版" class="headerlink" title="立即执行(升级版)"></a>立即执行(升级版)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">500</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//每次清空上一次调用时触发的定时器,timer变量存储的id值不变</span></span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一次调用匿名函数或者在timer被置为null后调用匿名函数都会直接调用fn</span></span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次调用匿名函数都会触发定时器，在delay期间，timer是有id值的，所以fn不会调用</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p>原先版本的防抖函数是延期执行fn，如果再次频繁的调用匿名函数去执行fn都会停止上一次的延期，再次重新重新设置延期，直到最后一次延期执行完毕没有再次触发事件，则会调用fn</p>
<p>立即执行版本的防抖函数正好相反，开始就准备执行fn，之后设置延期，如果再次频繁的调用匿名函数去执行fn同样会停止上一次的延期，再次重新设置延期，但是在每次调用匿名函数时都会尝试先去执行fn(立即执行)，直到最后一次触发后，也不会有反应，延期结束。过了延期后再一次触发，立即执行，再次设置延期……</p>
<p>总之，原版本的防抖函数频繁触发会延期，直到最后一次触发执行操作，立即执行版本是初始第一次就立即执行，之后的频繁操作是不会有响应操作的</p>
<p>注意：这里说的是一个连续的过程</p>
<h3 id="节流-throttling"><a href="#节流-throttling" class="headerlink" title="节流(throttling)"></a>节流(throttling)</h3><p>原理：在固定周期内只执行一次，后续再次触发则要等到过了这个周期才可以再次触发</p>
<p>场景：提交按钮，在固定时间(可能是没几秒)只点击一次有效</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttling</span>(<span class="params">fn, delay = <span class="number">2000</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> Do = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Do) &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            Do = <span class="literal">false</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                Do = <span class="literal">true</span></span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>防抖和节流都利用了闭包的思想，返回了一个引用外部变量的匿名函数，这个外部变量就是每次是否可以调用fn的判断依据</p>
<p>节流和防抖的区别在于防抖针对超高频率的触发事件会不停的延期，要么开始就触发要么最后一次触发。而节流是固定一个时间段内只可以触发一次过了这个时间段才可以再次触发。</p>
]]></content>
      <categories>
        <category>关于JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
